---
title: "Notes: Initialising a SEIR model from incidence data"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(diseasy)

run_EI_blocks <- FALSE
run_SR_blocks <- TRUE
```

# Introduction
Let us begin by considering a general SEIR model with $K$ and $L$ consecutive $E$ and $I$ states respectively, 
which are governed by the rates $r_e$ and $r_i$ respectively.

Let us further assume that we have some signal for infections which we would like our model to match.

For now, we operate with two possibilities:

1) The signal is related to incidence: $I^*(t)$ 

2) The signal is related to prevalence $I^\dag(t)$ 


The general approach is to consider the derivatives of the signal and link these to the E and I states of the model.

Dependent on the type of signal, there is some variation on how this link is established.


# Initialising EI states
The EI states of the SEIR model should match the most recent developments of the signal we want to match.

How to match this signal depends on the type of signal we have.


## Theory: Incidence signal
If the signal is incidence, we can assume that signal occurs when exiting $I_1$ in the model.

That is, we assume $I^* = r_i I_1$.

If we take the equation for $I_1$ and multiply by $r_i$ we obtain.

$$
r_i\frac{dI_1}{dt} = r_i r_e E_K - r_i^2 I_1 \Rightarrow \\
\frac{dI^*}{dt} = r_i r_e E_K - r_i I^*
$$
If we take the second derivative, we find:
$$
\frac{d^2I^*}{dt^2} = r_i r_e \frac{dE_K}{dt} - r_i \frac{dI_l}{dt}
$$
From here, we can inject $\frac{dE_K}{dt}$ from the SEIR equations which in turn relates to $E_{k-1}$.
$$
\frac{d^2I^*}{dt^2} = r_i r_e \left(r_e E_{K-1} - r_e E_K\right) - r_i \frac{dI_l}{dt}
$$

This process can be iterated through the derivatives until all $E_K$ states are expressed in terms of $I^*(t)$ and
its derivatives.

In this case, we can relate the $E_k$ states to the rates and derivatives of the signal in a simple form:

$$
r_i
\begin{bmatrix}
r_e E_K \\
r_e^2 E_{K-1} \\
\dots \\
r_e^{K-1} E_2 \\
r_e^K E_1 \\
\end{bmatrix}
=
\overline{\overline{M_K}} \cdot
\begin{bmatrix}
I^* \\
\frac{dI^*}{dt} \\
\dots \\
\frac{d^KI^*}{dt^K} \\
\frac{d^{K+1}I^*}{dt^{K+1}}
\end{bmatrix}
$$


The matrix $\overline{\overline{M_K}}$ can be computed via a simple recursion. To see why, start the equation for the
derivative of $I^*(t)$: 

$$
\frac{dI^*}{dt} = r_i r_e E_K - r_i I^*
$$
In the above formulation, this corresponds to the matrix 
$\overline{\overline{M_1}} = \begin{bmatrix}r_i & 1\end{bmatrix}$. 

When taking the second derivative, we obtain:

$$\frac{d^2I^*}{dt^2} = r_ir_e \frac{dE_K}{dt}- r_i \frac{dI^*}{dt} \Rightarrow \\
\frac{d^2I^*}{dt^2} = r_i r_e \left(r_e E_{K-1} - r_e E_K\right) - r_i \frac{dI^*}{dt} \Rightarrow \\
\frac{d^2I^*}{dt^2} = r_i r_e^2 E_{k-1} - r_e\left(r_i \frac{dI^*}{dt} + I^*\right)- r_i \frac{dI^*}{dt}$$
 
Which, in the matrix formulation corresponds to the sum of $r_e \overline{m_1}$ and the shifted $\overline{m_1}$,
where $\overline{m_1}$ is the row vector of $\overline{\overline{M_1}}$.

More precisely:
$$
\overline{m_2} = r_e \begin{bmatrix}\overline{m_1} & 0 \end{bmatrix}+ \begin{bmatrix}0 & \overline{m_1}\end{bmatrix}
$$
Which, combined with $\overline{m_1}$ yields the two level system:

$$
\overline{\overline{M_2}} = \begin{bmatrix}m_{11} & m_{12} & 0 \\ m_{21} & m_{22} & m_{23} \end{bmatrix}
$$
 
The algorithmic implementation of the recursion is then:
```{r}
K <- 4
ri <- 0.9
re <- 0.8

M <- matrix(rep(0, K * (K + 1)), nrow = K) # Pre-allocate
active_row <- c(ri, 1)

for (k in seq(K)) {
  if (k > 1) active_row <- c(0, active_row) + re * c(active_row, 0)

  M[k, seq(k + 1)] <- active_row
}

M
```


Since we assume that the signal $I^*$ only relates to $I_1$, then we can determine the $I_l$ states by evaluating the
signal at $I^*(t - (l - 1) / r_i)$.


## Theory: Prevalence signal
If we instead have a measure of the true number of infected, $I^\dag = \sum_l I_l$, then the situation is more
complicated since the derivative becomes:
$$\frac{dI^\dag}{dt} = r_e E_K - r_i I_l$$

If use the same method as before, we now have to consider the derivatives of both $I^\dag$ and $I_l$ and we cannot
isolate easily. 

We can however, determine how the derivatives of $I^\dag$ relates to the state vector.

For example, if we have 2 $E$ and 2 $I$ states, we can write:
$$
\begin{bmatrix}
0 & r_e & 0 & -r_i \\
r_e^2 & -r_e^2 & -r_i^2 & r_i^2 \\
\end{bmatrix} \cdot
\begin{bmatrix}
E_1 \\
E_2 \\
I_1 \\
I_2
\end{bmatrix}
=
\begin{bmatrix}
\frac{dI^\dag}{dt} \\
\frac{d^2I^\dag}{dt^2}
\end{bmatrix}
$$
Which, with two additional constants, $I^\dag = I_1 + I_2$ and $E_1 + E_2 + I_1 + I_2 = 1 - \beta S I^\dag$, can be solved.

If we want more states, the problem seemingly becomes indeterminate:
$$
\begin{bmatrix}
0 & 0 & r_e & 0 & 0 & -r_i \\
0 & r_e^2 & -r_e^2 & 0 & -r_i^2 & r_i^2 \\
r_e^3 & -2r_e^3 & r_e^3 & r_i^3 & -2r_i^3 & r_i^3 \\
\end{bmatrix} \cdot
\begin{bmatrix}
E_1 \\
E_2 \\
E_3 \\
I_1 \\
I_2 \\
I_3
\end{bmatrix}
=
\begin{bmatrix}
\frac{dI^\dag}{dt} \\
\frac{d^2I^\dag}{dt^2} \\
\frac{d^3I^\dag}{dt^3}
\end{bmatrix}
$$
Which now requires three additional constraints.

If the number of states is uneven, we can still solve some cases:

2 $E$ states and 1 $I$ states

$$
\begin{bmatrix}
0 & r_e & -r_i \\
r_e^2 & -r_e^2-r_er_i & r_i^2 \\
\end{bmatrix} \cdot
\begin{bmatrix}
E_1 \\
E_2 \\
I
\end{bmatrix}
=
\begin{bmatrix}
\frac{dI^\dag}{dt} \\
\frac{d^2I^\dag}{dt^2}
\end{bmatrix}
$$
With the additional constraint $I^\dag = I_1 + I_2$ the system should be solvable.

The above rate-matrices can also be implemented via recursion algorithmically:
```{r}
K <- L <- 2
ri <- 0.9
re <- 0.8

M <- matrix(rep(0, (K + L) * K), ncol = K + L) # Pre-allocate
active_row <- c(rep(0, K - 1), re, rep(0, L - 1), -ri)
progression_rates <- c(rep(re, K), rep(ri, L))

for (k in seq(K)) {
  
  if (k > 1) {
    stopifnot(active_row[[1]] == 0) # We cannot iterate too deeply

    # Implement branching process which picks up the progression rate
    # factors as it branches down.
    active_row <- active_row |>
      purrr::imap(
        \(r, idx) {
          c(
            rep(0, max(0, idx - 2)), # left pad with zeros
            progression_rates[idx - 1] * r,
            - progression_rates[idx] * r,
            rep(0, K + L - idx) # right pad with zeros
          )
        }
      ) |>
      purrr::reduce(`+`)
  }

  M[k, ] <- active_row
}

M
```


<!-- Another method for gaining additional constraints on the problem is to keep some in reserve for the fititng. -->
<!-- By that, I mean that if we instead of initialising the state vector for time $t_0$, we initialise it for time $t_0' \equiv t_0 - 1 / r_i$.  -->

<!-- In this case, we can consider what the signal $I^\dag(t + 1/r_i)$ corresponds to in the model. -->
<!-- If we assume that $r_e <= r_i$, we can write: -->
<!-- $$ -->
<!-- I^\dag(t + 1/r_i) = \sum_l^{L-1}I_l(t) + \frac{r_e}{r_i}E_K(t) -->
<!-- $$ -->
<!-- If instead $r_e > r_i$, we need to account for additional $E_k$ states. -->


It seems that the problem is singular whenever we have more than 1 $I$ state.

Let's see if differences in infectivity can help break this degeneracy.
In this case, the true signal becomes, $I^\dag = \sum_l w_l I_l$, with $w_i \neq w_j$.

The derivative then becomes
$$
\frac{dI^\dag}{dt} = w_1 r_e E_K - w_1 r_i I_1 \\ 
+ w_2 r_i I_1 - w_2 r_i I_2 \\
\dots \\
+ w_L r_i I_{L-1}  - w_L r_i I_L
$$
$$
\begin{bmatrix}
0         &  w_1 r_e                       &  (w_2-w_1) r_i               & -w_2 r_i \\
w_1 r_e^2 & -w_1 r_e^2 + (w_2-w_1) r_i r_e & -(w_2-w_1) r_i^2 - w_2 r_i^2 &  w_2 r_i^2
\end{bmatrix} \cdot
\begin{bmatrix}
E_1 \\
E_2 \\
I_1 \\
I_2
\end{bmatrix}
=
\begin{bmatrix}
\frac{dI^\dag}{dt} \\
\frac{d^2I^\dag}{dt^2}
\end{bmatrix}
$$

The matrix generation is the same.

<!-- The matrix is still singular when using the offset method. Perhaps if we can estimate S and R. -->

<!-- Constraining the population to be 1 does not seem to fix the underlying issues. The balance of the states is way off. -->

<!-- Perhaps if we go one stage further and use the infection pressure "beta S I"? -->



## Testing the methods

We begin by generating some synthetic data from different underlying data-generating processes.
```{r synthetic_data, include = FALSE}
# Set the time scales of the problem
rE = 1 / 2
rI = 1 / 4

combinations <- data.frame(K = c(1, 1, 2, 2, 2, 3), L = c(1, 2, 1, 2, 3, 3))

synthetic_model <- combinations |>
  purrr::pmap(\(K, L) {
    
    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = L, "R" = 1),
      disease_progression_rates = c("E" = rE, "I" = rI),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0.6)
    )
    
    # Get a reference to the private environment
    private <- m$.__enclos_env__$private
    
    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(0.001, rep(0, K - 1), rep(0, L), 0, 0.999)
    
    # Run solver across scenario change to check for long-term leakage
    deSolve::ode(y = y0, times = seq(0, 60), func = private %.% rhs, parms = NULL)
  })

names(synthetic_model) <- purrr::pmap_chr(combinations, \(K, L) glue::glue("K = {K}, L = {L}"))

```

With the true solutions generated, we now generate some observational signal with noise from the $I_1$ state.
```{r}
tmax <- 38
offset <- 7
t0 <- tmax - offset

incidence_signal <- purrr::imap(synthetic_model, ~ {
  n_states <-as.numeric(stringr::str_extract_all(.y, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]
  
  # Retrieve the signal
  I <- L * rI * head(.x[, K + 2], tmax)
  
  # Adding some noise
  pop = 1e3
  II <- purrr::map_dbl(I, \(lambda) rpois(1, pop * lambda)) / pop  
  
  data.frame(t = head(.x[, 1], tmax), incidence = II)
})

incidence_signal_gg <- purrr::imap(incidence_signal, ~ dplyr::mutate(.x, true_configuration = .y)) |>
  purrr::list_rbind()

ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_point() + 
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw() 

```

We define a function to run the model forward based on the estimated initial state vector.
```{r}
run_model <- function(EI_states, R, S, K, L, rE, rI, offset = 0, signal = "incidence", scale_EI = TRUE) {
  checkmate::assert_numeric(EI_states, lower = 0)
  checkmate::assert_choice(signal, c("incidence", "prevalence"))
  
  # Run a SIR model to generate the target of our initialisation
  m <- DiseasyModelOdeSeir$new(
    season = T, activity = T,
    observables = DiseasyObservables$new(
      conn = DBI::dbConnect(RSQLite::SQLite()),
      last_queryable_date = Sys.Date() - 1
    ),
    variant = DiseasyVariant$new(n_variants = 1),
    compartment_structure = c("E" = K, "I" = L, "R" = 1),
    disease_progression_rates = c("E" = rE, "I" = rI),
    parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0.6)
  )
  
  # Get a reference to the private environment
  private <- m$.__enclos_env__$private


  times <- seq(0, 10, length.out = 100) + offset
  
  if (scale_EI) {
    y0 <- c(EI_states / sum(EI_states) * (1 - R - S), R, S)
  } else {
    y0 <- c(EI_states, R / S * (1 - sum(EI_states)), (1 - R / S) * (1 - sum(EI_states)))
  }
  
  sol <- deSolve::ode(
    y = y0,
    times = times, 
    func = private %.% rhs, 
    parms = NULL,
    abstol = 1e-12, reltol = 1e-12
  )

  
  if (signal == "incidence") {
    return(data.frame(t = t0 + times, incidence = L * rI * sol[, K + 2]))
  } else if (signal == "prevalence") {
    return(data.frame(t = t0 + times, prevalence = rowSums(sol[, (K + 2):(K + L + 1), drop = FALSE])))
  }
  
}
```

And then we can run this model using the true state from the model to check that it works as expected 
```{r}
exact_incidence_fit_gg <- purrr::imap(synthetic_model, ~ {
  n_states <-as.numeric(stringr::str_extract_all(.y, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]
  
  t <- .x[, 1]
  E <- .x[t == t0, 2:(K + 1)]
  I <- .x[t == t0, (K + 2):(K + L + 1)]
  R <- .x[t == t0, 1 + K + L+ 1]
  S <- .x[t == t0, 1 + K + L + 2]
  
  run_model(c(E, I), R, S, K, L, rE, rI, signal = "incidence") |>
    dplyr::mutate(true_configuration = .y, model_configuration = .y)
}) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_incidence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```


```{r}
prevalence_signal <- purrr::imap(synthetic_model, ~ {
  n_states <-as.numeric(stringr::str_extract_all(.y, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]
  
  # Retrieve the signal
  I <- rowSums(head(.x[, (1 + K + 1):(1 + K + L), drop = FALSE], tmax))
  
  # Adding some noise
  pop = 1e3
  II <- purrr::map_dbl(I, \(lambda) rpois(1, pop * lambda)) / pop  
  
  data.frame(t = head(.x[, 1], tmax), prevalence = II)
})

prevalence_signal_gg <- purrr::imap(prevalence_signal, ~ dplyr::mutate(.x, true_configuration = .y)) |>
  purrr::list_rbind()

ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_point() + 
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw() 

```

```{r}
exact_prevalence_fit_gg <- purrr::imap(synthetic_model, ~ {
  n_states <-as.numeric(stringr::str_extract_all(.y, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]
  
  t <- .x[, 1]
  E <- .x[t == t0, 2:(K + 1)]
  I <- .x[t == t0, (K + 2):(K + L + 1)]
  R <- .x[t == t0, 1 + K + L+ 1]
  S <- .x[t == t0, 1 + K + L + 2]
  
  run_model(c(E, I), R, S, K, L, rE, rI, signal = "prevalence") |>
    dplyr::mutate(true_configuration = .y, model_configuration = .y)
}) |>
  purrr::list_rbind()


ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_line(data = exact_prevalence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

## Implementation: Incidence signal

We see that the fitting works given perfect information.

Now lets estimate the state vector from the (noisy) synthetic signal.

<!-- $$ -->
<!-- P_2(x) = ax + bx^2 -->
<!-- $$ -->

<!-- $$ -->
<!-- \log I = a_0 +  a_1 x + a_2 + x^2 \Rightarrow\\ -->
<!-- I = e^{a_0 + a_1 x + a_2 x^2} \Rightarrow\\ -->
<!-- I = \tilde{a_0} e^{a_1x}e^{a_2 x^2} -->
<!-- $$ -->

This method relies on fitting a polynomial to the latest period, so we do that here.
```{r, eval = run_EI_blocks}
poly_order <- 3

incidence_polyfits <- purrr::map(incidence_signal, ~ {
  lm(incidence ~ poly(t, poly_order, raw = TRUE), data = dplyr::filter(dplyr::mutate(.x, t = t - t0), t <= 0, t > -21))
})

incidence_polyfit_projections <- incidence_polyfits |> 
  purrr::map(~ data.frame(t = incidence_signal[[1]]$t, incidence = predict(.x, data.frame(t = incidence_signal[[1]]$t - t0))))

incidence_polyfit_projections_gg <- purrr::imap(incidence_polyfit_projections, ~ dplyr::mutate(.x, true_configuration = .y)) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = incidence_polyfit_projections_gg, color = "red", linewidth = 1) +
  ggplot2::geom_vline(xintercept = t0,      linetype = 2, color = "red") +
  ggplot2::geom_vline(xintercept = t0 - 20, linetype = 2, color = "red") +
  ggplot2::geom_hline(
    ggplot2::aes(yintercept = c0),
    linetype = 2, color = "red",
    data = data.frame(c0 = purrr::map_dbl(incidence_polyfits, ~ purrr::pluck(.x, "coefficients", 1)),
                      true_configuration = names(incidence_polyfits))
  ) + 
  ggplot2::geom_point() +
  ggplot2::ylim(0, 1.2*max(incidence_signal_gg$incidence)) +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

The method relies on a vector of derivatives of the signal, which we compute here:

```{r, eval = run_EI_blocks}
# Compute the derivatives of the signal ("signal" vector)
max_order_derivative <- 2

incidence_signal_derivatives <- purrr::map(
  incidence_polyfits, ~ stats::setNames(
    .x$coefficients[1:(max_order_derivative + 1)] * pmax(1, seq(max_order_derivative + 1) - 1),
    c("I^*", "dI^*/dt", "d^2I^*/dt^2")
  )
)
  
incidence_signal_derivatives
```
### Direct inference from incidence signal
Now we use the method to estimate the EI states from the signal.
(Assuming we have the correct model specification)

```{r, eval = run_EI_blocks}
incidence_model_fit_gg <- purrr::map(names(incidence_signal_derivatives), ~ {
  n_states <- as.numeric(stringr::str_extract_all(.x, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]
  
  ri <- rI * L
  re <- rE * K
  
  M <- matrix(rep(0, K * (K + 1)), nrow = K)
  active_row <- c(ri, 1)
  
  for (k in seq(K)) {
    if (k > 1) {
      active_row <- c(0, active_row) + re * c(active_row, 0)
    }
  
    M[k, seq(k + 1)] <- active_row
  }
  
  # Define the vector for the matrix multiplication
  ss <- incidence_signal_derivatives[[.x]][1:(K + 1)] 
  ss[is.na(ss)] <- 0
  
  E_k <- rev(as.numeric(M %*% ss) / (ri * cumprod(rep(re, K))))

  I_star <- predict(incidence_polyfits[[.x]], data.frame(t = -(seq(L) - 1) / ri))
  I_l <- as.numeric(I_star) / ri

  EI_states <- c(E_k, I_l)
  
  t <- synthetic_model[[.x]][, 1]
  R <- synthetic_model[[.x]][t == t0, 1 + K + L + 1]
  S <- synthetic_model[[.x]][t == t0, 1 + K + L + 2]
  
  run_model(EI_states, R, S, K, L, rE, rI, signal = "incidence", scale_EI = TRUE) |>
    dplyr::mutate(true_configuration = .x, model_configuration = .x)
}) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_incidence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = incidence_model_fit_gg, color = "red", linewidth = 1) +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") + 
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

If we match the underlying model, and have perfect $R$ and $S$ estimation, we can estimate the initial state_vector
very well.

#### Scaling EI states
```{r, eval = run_EI_blocks}
incidence_model_fit_gg <- expand.grid(
  model_configuration = names(incidence_signal_derivatives),
  true_configuration  = names(incidence_signal_derivatives) 
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....
    
    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]
    
    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]
    
    
    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    ri <- rI * L
    re <- rE * K

    M <- matrix(rep(0, K * (K + 1)), nrow = K)
    active_row <- c(ri, 1)
    
    for (k in seq(K)) {
      if (k > 1) {
        active_row <- c(0, active_row) + re * c(active_row, 0)
      }
    
      M[k, seq(k + 1)] <- active_row
    }

    # Define the vector for the matrix multiplication
    ss <- incidence_signal_derivatives[[true_configuration]][1:(K + 1)] 
    ss[is.na(ss)] <- 0

    E_k <- rev(as.numeric(M %*% ss) / (ri * cumprod(rep(re, K))))
  
    I_star <- predict(incidence_polyfits[[true_configuration]], data.frame(t = -(seq(L) - 1) / ri))
    I_l <- as.numeric(I_star) / ri
    
    
    EI_states <- c(E_k, I_l)

    run_model(EI_states, R, S, K, L, rE, rI, signal = "incidence", scale_EI = TRUE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_incidence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = incidence_model_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") + 
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

#### Scaling RS states
```{r, eval = run_EI_blocks}
direct_incidence_fit_gg <- expand.grid(
  model_configuration = names(incidence_signal_derivatives),
  true_configuration  = names(incidence_signal_derivatives) 
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....
    
    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]
    
    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]
    
    
    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    ri <- rI * L
    re <- rE * K

    M <- matrix(rep(0, K * (K + 1)), nrow = K)
    active_row <- c(ri, 1)
    
    for (k in seq(K)) {
      if (k > 1) {
        active_row <- c(0, active_row) + re * c(active_row, 0)
      }
    
      M[k, seq(k + 1)] <- active_row
    }

    # Define the vector for the matrix multiplication
    ss <- incidence_signal_derivatives[[true_configuration]][1:(K + 1)] 
    ss[is.na(ss)] <- 0

    E_k <- rev(as.numeric(M %*% ss) / (ri * cumprod(rep(re, K))))
  
    I_star <- predict(incidence_polyfits[[true_configuration]], data.frame(t = -(seq(L) - 1) / ri))
    I_l <- as.numeric(I_star) / ri
    
    EI_states <- c(E_k, I_l)

    run_model(EI_states, R, S, K, L, rE, rI, signal = "incidence", scale_EI = FALSE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_incidence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = direct_incidence_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") + 
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```


### Initialising via solving the ODE of simplified system
A different approach we can try, is to estimate the state vector not at time $t = 0$, but rather at time $t = -1/r_E$ (where $r_E = r_e / N$).
The idea here is to not include any new infection in the model, and only run the $E$ and $I$ states through the model.

If we have a test signal, we can try to only include the first $I$ state and then run the model.
If we have a prevalence signal, we need to include all $I$ states.


```{r, eval = run_EI_blocks}
simplified_incidence_fit_gg <- purrr::map(names(incidence_signal_derivatives), ~ {
  n_states <- as.numeric(stringr::str_extract_all(.x, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]
  
  ri <- rI * L
  re <- rE * K
  
  # Generate a uniform initial state_vector that sums to 1
  y0 <- c(rep(1, K + 1), 0, 0)
  y0 <- y0 / sum(y0)
  
  times <- seq(- 1 / rE, 0, length.out = 10)
  ss <- predict(incidence_polyfits[[.x]], data.frame(t = times))
   
  
  # Run a SIR model to generate the target of our initialisation
  m <- DiseasyModelOdeSeir$new(
    season = T, activity = T,
    observables = DiseasyObservables$new(
      conn = DBI::dbConnect(RSQLite::SQLite()),
      last_queryable_date = Sys.Date() - 1
    ),
    variant = DiseasyVariant$new(n_variants = 1),
    compartment_structure = c("E" = K, "I" = 1, "R" = 1),
    disease_progression_rates = c("E" = rE, "I" = ri),
    parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0),
    malthusian_matching = FALSE
  )
  
  # Get a reference to the private environment
  private <- m$.__enclos_env__$private
  
  objective_function <- function(y) {
    sol <- deSolve::ode(
      y = y, 
      times = times, 
      func = private %.% rhs, 
      parms = NULL
    ) 
  
    I1 <- sol[, K + 2]
    
    sum(ri * I1 - ss)^2
  }
  
  op <- optim(
    par = y0,
    fn = objective_function,
    method = "L-BFGS-B",
    lower = 0, 
    control = list(factr = 1e-2 / .Machine$double.eps)
  ) 
  
  EI_states <- op$par[1:(K + 1)]
  
  if (L > 1) {
    I_l <- predict(incidence_polyfits[[.x]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()  
    EI_states <- c(EI_states, I_l)
  }

  t <- synthetic_model[[.x]][, 1]
  R <- synthetic_model[[.x]][t == t0, 1 + K + L + 1]
  S <- synthetic_model[[.x]][t == t0, 1 + K + L + 2]
  
  run_model(EI_states, R, S, K, L, rE, rI, offset = 0, signal = "incidence", scale_EI = TRUE) |>
    dplyr::mutate(true_configuration = .x, model_configuration = .x)
}) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_incidence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_incidence_fit_gg, color = "red", linewidth = 1) +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") + 
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

#### Scaling EI states
```{r, eval = run_EI_blocks}
simplified_incidence_fit_gg <- expand.grid(
  model_configuration = names(incidence_signal_derivatives),
  true_configuration  = names(incidence_signal_derivatives) 
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....
    
    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]
    
    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]
    
    
    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]
    
    ri <- rI * L
    re <- rE * K
    
    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(rep(1, K + 1), 0, 0)
    y0 <- y0 / sum(y0)
    
    times <- seq(- 1 / rE, 0, length.out = 10)
    ss <- predict(incidence_polyfits[[true_configuration]], data.frame(t = times))
    
    
    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = 1, "R" = 1),
      disease_progression_rates = c("E" = rE, "I" = ri),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0),
      malthusian_matching = FALSE
    )
    
    # Get a reference to the private environment
    private <- m$.__enclos_env__$private
     
    
    objective_function <- function(y) {
      sol <- deSolve::ode(
        y = y, 
        times = times, 
        func = private %.% rhs, 
        parms = NULL
      ) 
    
      I1 <- sol[, K + 2]
      
      sum(ri * I1 - ss)^2
    }
    
    op <- optim(
      par = y0,
      fn = objective_function,
      method = "L-BFGS-B",
      lower = 0,
      control = list(factr = 1e-2 / .Machine$double.eps)
    ) 
    
    EI_states <- op$par[1:(K + 1)]
    
    if (L > 1) {
      I_l <- predict(incidence_polyfits[[true_configuration]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()  
      EI_states <- c(EI_states, I_l)
    }

    run_model(EI_states, R, S, K, L, rE, rI, signal = "incidence", scale_EI = TRUE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }, .progress = TRUE) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_incidence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_incidence_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") + 
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

#### Scaling RS states
```{r, eval = run_EI_blocks}
simplified_incidence_fit_gg <- expand.grid(
  model_configuration = names(incidence_signal_derivatives),
  true_configuration  = names(incidence_signal_derivatives) 
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....
    
    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]
    
    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]
    
    
    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]
    
    ri <- rI * L
    re <- rE * K
    
    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(rep(1, K + 1), 0, 0)
    y0 <- y0 / sum(y0)
    
    times <- seq(- 1 / rE, 0, length.out = 10)
    ss <- predict(incidence_polyfits[[true_configuration]], data.frame(t = times))
    
    
    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = 1, "R" = 1),
      disease_progression_rates = c("E" = rE, "I" = ri),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0),
      malthusian_matching = FALSE
    )
    
    # Get a reference to the private environment
    private <- m$.__enclos_env__$private
     
    
    objective_function <- function(y) {
      sol <- deSolve::ode(
        y = y, 
        times = times, 
        func = private %.% rhs, 
        parms = NULL
      ) 
    
      I1 <- sol[, K + 2]
      
      sum(ri * I1 - ss)^2
    }
    
    op <- optim(
      par = y0,
      fn = objective_function,
      method = "L-BFGS-B",
      lower = 0,
      control = list(factr = 1e-2 / .Machine$double.eps)
    ) 
    
    EI_states <- op$par[1:(K + 1)]
    
    if (L > 1) {
      I_l <- predict(incidence_polyfits[[true_configuration]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()  
      EI_states <- c(EI_states, I_l)
    }

    run_model(EI_states, R, S, K, L, rE, rI, signal = "incidence", scale_EI = FALSE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }, .progress = TRUE) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_incidence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_incidence_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") + 
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```





## Implementation: Prevalence signal

And now for the prevalence

This method relies on fitting a polynomial to the latest period, so we do that here.
```{r, eval = run_EI_blocks}
poly_order <- 3

prevalence_polyfits <- purrr::map(prevalence_signal, ~ {
  lm(prevalence ~ poly(t, poly_order, raw = TRUE), data = dplyr::filter(dplyr::mutate(.x, t = t - t0), t <= 0))
})

prevalence_polyfit_projections <- prevalence_polyfits |> 
  purrr::map(~ data.frame(t = prevalence_signal[[1]]$t, prevalence = predict(.x, data.frame(t = prevalence_signal[[1]]$t - t0))))

prevalence_polyfit_projections_gg <- purrr::imap(prevalence_polyfit_projections, ~ dplyr::mutate(.x, true_configuration = .y)) |>
  purrr::list_rbind()


ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_line(data = prevalence_polyfit_projections_gg, color = "red", linewidth = 1) +
  ggplot2::geom_vline(xintercept = t0,      linetype = 2, color = "red") +
  ggplot2::geom_vline(xintercept = t0 - 20, linetype = 2, color = "red") +
  ggplot2::geom_hline(
    ggplot2::aes(yintercept = c0),
    linetype = 2, color = "red",
    data = data.frame(c0 = purrr::map_dbl(prevalence_polyfits, ~ purrr::pluck(.x, "coefficients", 1)),
                      true_configuration = names(prevalence_polyfits))
  ) + 
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

The method relies on a vector of derivatives of the signal, which we compute here:

```{r, eval = run_EI_blocks}
# Compute the derivatives of the signal ("signal" vector)
max_order_derivative <- 2

prevalence_signal_derivatives <- purrr::map(
  incidence_polyfits, ~ stats::setNames(
    .x$coefficients[1:(max_order_derivative + 1)] * pmax(1, seq(max_order_derivative + 1) - 1),
    c("I^*", "dI^*/dt", "d^2I^*/dt^2")
  )
)
  
prevalence_signal_derivatives
```
### Direct inference from prevalence signal
```{r}  
# prevalence_model_fit_gg <- purrr::map(names(prevalence_signal_derivatives), ~ {
#   n_states <- as.numeric(stringr::str_extract_all(.x, r"{\d}")[[1]])
#   K <<- n_states[1]
#   L <<- n_states[2]
#   
#   ri <<- rI * L
#   re <<- rE * K
#   
#   # Compute the matrix
#   M <- matrix(rep(0, (K + L) * K), ncol = K + L)
#   active_row <- c(rep(0, K - 1), re, rep(0, L - 1), -ri)
#   progression_rates <- c(rep(re, K), rep(ri, L))
#   
#   for (k in seq(K)) {
#     if (k > 1) {
#       stopifnot(active_row[[1]] == 0) # We cannot iterate too deeply
#     
#       # Implement branching process which picks up the progression rate factors as it branches down.
#       active_row <- active_row |>
#         purrr::imap(
#           \(r, idx) {
#             c(
#               rep(0, max(0, idx - 2)), # left pad with zeros
#               progression_rates[idx - 1] * r,
#               - progression_rates[idx] * r,
#               rep(0, K + L - idx) # right pad with zeros
#             )
#           }
#         ) |>
#         purrr::reduce(`+`)
#     }
#   
#     M[k, ] <- active_row
#   }
#   
#   # Define the vector for the matrix multiplication
#   ss <- prevalence_signal_derivatives[[.x]][2:(K + 1)]
#   ss[is.na(ss)] <- 0
#   
#   checkmate::assert_number(nrow(M), lower = ncol(M) - 2, upper = ncol(M))
#   
#   # Add additional constraints
#   # I* = sum_l I_l
#   if (nrow(M) < ncol(M)) {
#     M <- rbind(
#       M, 
#       c(rep(0, K), rep(1, L))
#     )
#     ss <- c(ss, prevalence_signal_derivatives[[.x]][1])
#   }
#   
#   # Add additional constraints
#   # I*(1/re) = sum_l^(L-1) I_l + ri/re I_l + E_k
#   if (nrow(M) < ncol(M)) {
#     time_ratio <- re / ri
#     l <- min(floor(time_ratio), L)
#     contribution <- c(rep(1, L - l), rep(0, l))
#     contribution[max(L - l, 1)] <- 1 - (1 + time_ratio) %% 1
#     
#     M <- rbind(
#       M, 
#       c(rep(0, K - 1), 1, contribution)
#     )
#     ss <- c(ss, predict(prevalence_polyfits[[.x]], data.frame(t = - max(K, L) / ri * 0.5)))
#   }
#   
#   M <<- M
#   ss <<- ss
#   EI_states <- solve(M, ss)
#   
#   print(EI_states)
# 
#   t <- synthetic_model[[.x]][, 1]
#   R <- synthetic_model[[.x]][t == t0, 1 + K + L + 1]
#   S <- synthetic_model[[.x]][t == t0, 1 + K + L + 2]
#   
#   run_model(EI_states, R, S, K, L, rE, rI, signal = "prevalence", scale_EI = TRUE) |>
#     dplyr::mutate(true_configuration = .x, model_configuration = .x)
# }) |>
#   purrr::list_rbind()
# 
# 
# ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
#   ggplot2::geom_line(data = exact_prevalence_fit_gg, color = "darkgrey", linewidth = 2) +
#   ggplot2::geom_line(data = prevalence_model_fit_gg, color = "red", linewidth = 1) +
#   ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") + 
#   ggplot2::geom_point() +
#   ggplot2::facet_wrap(~ true_configuration) +
#   ggplot2::theme_bw()
```




### Initialising via solving the ODE of simplified system
```{r, eval = run_EI_blocks}
simplified_model_fit_gg <- purrr::map(names(prevalence_signal_derivatives), ~ {
  n_states <- as.numeric(stringr::str_extract_all(.x, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]
  
  ri <- rI * L
  re <- rE * K
  
  # Generate a uniform initial state_vector that sums to 1
  y0 <- c(rep(1, K + L), 0, 0)
  y0 <- y0 / sum(y0)
  
  times <- seq(- 1 / rE, 0, length.out = 10)
  ss <- predict(prevalence_polyfits[[.x]], data.frame(t = times))
  
  
  # Run a SIR model to generate the target of our initialisation
  m <- DiseasyModelOdeSeir$new(
    season = T, activity = T,
    observables = DiseasyObservables$new(
      conn = DBI::dbConnect(RSQLite::SQLite()),
      last_queryable_date = Sys.Date() - 1
    ),
    variant = DiseasyVariant$new(n_variants = 1),
    compartment_structure = c("E" = K, "I" = L, "R" = 1),
    disease_progression_rates = c("E" = rE, "I" = rI),
    parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0),
    malthusian_matching = FALSE
  )
  
  # Get a reference to the private environment
  private <- m$.__enclos_env__$private
  
  objective_function <- function(y) {
    sol <- deSolve::ode(
      y = y, 
      times = times, 
      func = private %.% rhs, 
      parms = NULL
    ) 
  
    I <- rowSums(sol[, (1 + K + 1):(1 + K + L), drop = FALSE])
    
    sum(I - ss)^2
  }
  
  op <- optim(
    par = y0,
    fn = objective_function,
    method = "L-BFGS-B",
    lower = 0
  ) 
  
  EI_states <- op$par[1:(K + 1)]
  
  if (L > 1) {
    I_l <- predict(prevalence_polyfits[[.x]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()  
    EI_states <- c(EI_states, I_l)
  }

  t <- synthetic_model[[.x]][, 1]
  R <- synthetic_model[[.x]][t == t0, 1 + K + L + 1]
  S <- synthetic_model[[.x]][t == t0, 1 + K + L + 2]
  
  run_model(EI_states, R, S, K, L, rE, rI, signal = "prevalence", scale_EI = TRUE) |>
    dplyr::mutate(true_configuration = .x, model_configuration = .x)
}) |>
  purrr::list_rbind()


ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_line(data = exact_prevalence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_model_fit_gg, color = "red", linewidth = 1) +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") + 
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

#### Scaling EI states
```{r, eval = run_EI_blocks}
simplified_prevalence_fit_gg <- expand.grid(
  model_configuration = names(prevalence_signal_derivatives),
  true_configuration  = names(prevalence_signal_derivatives) 
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....
    
    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]
    
    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]
    
    
    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]
    
    ri <- rI * L
    re <- rE * K
    
    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(rep(1, K + 1), 0, 0)
    y0 <- y0 / sum(y0)
    
    times <- seq(- 1 / rE, 0, length.out = 10)
    ss <- predict(prevalence_polyfits[[true_configuration]], data.frame(t = times))
    
    
    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = 1, "R" = 1),
      disease_progression_rates = c("E" = rE, "I" = ri),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0),
      malthusian_matching = FALSE
    )
    
    # Get a reference to the private environment
    private <- m$.__enclos_env__$private
     
    
    objective_function <- function(y) {
      sol <- deSolve::ode(
        y = y, 
        times = times, 
        func = private %.% rhs, 
        parms = NULL
      ) 
    
      I1 <- sol[, K + 2]
      
      sum(ri * I1 - ss)^2
    }
    
    op <- optim(
      par = y0,
      fn = objective_function,
      method = "L-BFGS-B",
      lower = 0,
      control = list(factr = 1e-2 / .Machine$double.eps)
    ) 
    
    EI_states <- op$par[1:(K + 1)]
    
    if (L > 1) {
      I_l <- predict(prevalence_polyfits[[true_configuration]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()  
      EI_states <- c(EI_states, I_l)
    }

    run_model(EI_states, R, S, K, L, rE, rI, signal = "prevalence", scale_EI = TRUE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }, .progress = TRUE) |>
  purrr::list_rbind()


ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_line(data = exact_prevalence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_prevalence_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") + 
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```


#### Scaling RS states
```{r, eval = run_EI_blocks}
simplified_prevalence_fit_gg <- expand.grid(
  model_configuration = names(prevalence_signal_derivatives),
  true_configuration  = names(prevalence_signal_derivatives) 
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....
    
    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]
    
    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]
    
    
    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]
    
    ri <- rI * L
    re <- rE * K
    
    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(rep(1, K + 1), 0, 0)
    y0 <- y0 / sum(y0)
    
    times <- seq(- 1 / rE, 0, length.out = 10)
    ss <- predict(prevalence_polyfits[[true_configuration]], data.frame(t = times))
    
    
    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = 1, "R" = 1),
      disease_progression_rates = c("E" = rE, "I" = ri),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0),
      malthusian_matching = FALSE
    )
    
    # Get a reference to the private environment
    private <- m$.__enclos_env__$private
     
    
    objective_function <- function(y) {
      sol <- deSolve::ode(
        y = y, 
        times = times, 
        func = private %.% rhs, 
        parms = NULL
      ) 
    
      I1 <- sol[, K + 2]
      
      sum(ri * I1 - ss)^2
    }
    
    op <- optim(
      par = y0,
      fn = objective_function,
      method = "L-BFGS-B",
      lower = 0,
      control = list(factr = 1e-2 / .Machine$double.eps)
    ) 
    
    EI_states <- op$par[1:(K + 1)]
    
    if (L > 1) {
      I_l <- predict(prevalence_polyfits[[true_configuration]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()  
      EI_states <- c(EI_states, I_l)
    }

    run_model(EI_states, R, S, K, L, rE, rI, signal = "prevalence", scale_EI = FALSE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }, .progress = TRUE) |>
  purrr::list_rbind()


ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_line(data = exact_prevalence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_prevalence_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") + 
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```



# Initialising SR states
The SR states of the SEIR model should match the most recent developments of the signal we want to match.

How to match this signal depends on the type of signal we have.

## Theory: Incidence signal
If the signal, $I^*$, is test data, we can assume that tests occurs when exiting $I_1$ in the model.

That is, we assume $I^* = r_i I_1$.

We can modify the SEIR equation to take this signal as a forcing function with no $E$ states and one less $I$ state
(no $I_1$ state).

The equations are as normal expect for the following changes:
$$
I = \frac{I^*}{r_i} + \sum_{l=2}^L I_l
$$

$$
\frac{dI_2}{dt} = I^* - r_i I_2
$$
If we start this system at a time where there are no new infections, we can initialize $I_l = 0$, and run the 
simulation forward to estimate the $S$ and $R$ populations at the point of interest.

Note that we need to set $\beta = 0$ in the model to only have the forcing as the generation of new infected.

## Theory: Prevalence signal

If we instead have a measure of the true number of infected, $I\dag* = \sum_l I_l$, then we only need to force the 
infection pressure:

$$
I = I^\dag
$$
Here we would also need to start the system at a time where there are no new infections ($I_l = 0$).

## Implementation: Incidence signal


### Initialising via solving the ODE of simplified system

```{r, eval = run_SR_blocks}
simplified_incidence_fit_gg <- purrr::map(names(incidence_signal), ~ {
  n_states <- as.numeric(stringr::str_extract_all(.x, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]

  ri <- rI * L
  re <- rE * K

  # Run a SIR model to generate the target of our initialisation
  m <- DiseasyModelOdeSeir$new(
    season = T, activity = T,
    observables = DiseasyObservables$new(
      conn = DBI::dbConnect(RSQLite::SQLite()),
      last_queryable_date = Sys.Date() - 1
    ),
    variant = DiseasyVariant$new(n_variants = 1),
    compartment_structure = c("E" = 0, "I" = L - 1, "R" = 1),
    disease_progression_rates = c("I" = rI * L / (L- 1)),
    parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0),
    malthusian_matching = FALSE
  )

  # Get a reference to the private environment
  private <- m$.__enclos_env__$private

  # Get a interpolation of the signal
  signal <- approxfun(incidence_signal[[.x]]$t, incidence_signal[[.x]]$incidence, method = "constant")
  
  m$set_forcing_functions(
    infected_forcing = \(t, infected) signal(t) / ri + infected, # If L = 1, infected is numeric(0)
    state_vector_forcing = function(t, dy_dt) {
      dy_dt[private$i1_state_indexes] <- dy_dt[private$i1_state_indexes] - 
        signal(t) # Use signal as forcing for inflow to I1
      return(dy_dt)
    } 
  )

  
  # Create the starting state vector and the constraints
  y0 <- c(rep(0, L - 1), 0, 1)
  y0 <- y0 / sum(y0)
  
  times <- seq(from = 0, to = t0)
  
  sol <- deSolve::ode(
    y = y0,
    times = times,
    func = private %.% rhs,
    parms = NULL
  )
  
  R <- sol[nrow(sol), 1 + (L - 1) + 1]
  S <- sol[nrow(sol), 1 + (L - 1) + 2]
  
  R <- R / (R  + S)
  S <- S / (R  + S)
  
  
  t <- synthetic_model[[.x]][, 1]
  E <- synthetic_model[[.x]][t == t0, 1 + seq_len(K)]
  I <- synthetic_model[[.x]][t == t0, 1 + K + seq_len(L)]

  run_model(c(E, I), R, S, K, L, rE, rI, offset = 0, signal = "incidence", scale_EI = FALSE) |>
    dplyr::mutate(true_configuration = .x, model_configuration = .x)
}, .progress = TRUE) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_incidence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_incidence_fit_gg, color = "red", linewidth = 1) +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```


```{r, eval = run_SR_blocks}
simplified_incidence_fit_gg <- purrr::map(names(incidence_signal), ~ {
  n_states <- as.numeric(stringr::str_extract_all(.x, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]

  ri <- rI * L
  re <- rE * K

  # Run a SIR model to generate the target of our initialisation
  m <- DiseasyModelOdeSeir$new(
    season = T, activity = T,
    observables = DiseasyObservables$new(
      conn = DBI::dbConnect(RSQLite::SQLite()),
      last_queryable_date = Sys.Date() - 1
    ),
    variant = DiseasyVariant$new(n_variants = 1),
    compartment_structure = c("E" = 0, "I" = L - 1, "R" = 1),
    disease_progression_rates = c("I" = rI * L / (L- 1)),
    parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0),
    malthusian_matching = FALSE
  )

  # Get a reference to the private environment
  private <- m$.__enclos_env__$private

  # Get a interpolation of the signal
  signal <- approxfun(incidence_signal[[.x]]$t, incidence_signal[[.x]]$incidence, method = "constant")
  
  m$set_forcing_functions(
    infected_forcing = \(t, infected) signal(t) / ri + infected, # If L = 1, infected is numeric(0)
    state_vector_forcing = function(t, dy_dt) {
      dy_dt[private$i1_state_indexes] <- dy_dt[private$i1_state_indexes] - 
        signal(t) # Use signal as forcing for inflow to I1
      return(dy_dt)
    } 
  )

  
  # Create the starting state vector and the constraints
  y0 <- c(rep(0, L - 1), 0, 1)
  y0 <- y0 / sum(y0)
  
  times <- seq(from = 0, to = t0)
  

  
  objective_function <- function(beta) {

    private$.parameters$overall_infection_risk <- beta

    sol <- deSolve::ode(
      y = y0,
      times = times,
      func = private %.% rhs,
      parms = NULL
    )

    return((sum(sol[nrow(sol), -1]) - 1)^2)
  }

  op <- optim(
    par = 1,
    fn = objective_function,
    method = "L-BFGS-B",
    lower = 0#,
    #control = list(factr = 1e-2 / .Machine$double.eps)
  )

  # Use best beta
  private$.parameters$overall_infection_risk <- op$par
  
  sol <- deSolve::ode(
    y = y0,
    times = times,
    func = private %.% rhs,
    parms = NULL
  )
  
  R <- sol[nrow(sol), 1 + (L - 1) + 1]
  S <- sol[nrow(sol), 1 + (L - 1) + 2]
  
  R <- R / (R  + S)
  S <- S / (R  + S)
  
  
  t <- synthetic_model[[.x]][, 1]
  E <- synthetic_model[[.x]][t == t0, 1 + seq_len(K)]
  I <- synthetic_model[[.x]][t == t0, 1 + K + seq_len(L)]

  run_model(c(E, I), R, S, K, L, rE, rI, offset = 0, signal = "incidence", scale_EI = FALSE) |>
    dplyr::mutate(true_configuration = .x, model_configuration = .x)
}, .progress = TRUE) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_incidence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_incidence_fit_gg, color = "red", linewidth = 1) +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```



#### Scaling EI states
```{r, eval = run_SR_blocks}
simplified_incidence_fit_gg <- expand.grid(
  model_configuration = names(incidence_signal_derivatives),
  true_configuration  = names(incidence_signal_derivatives)
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....

    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]


    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]
  
    ri <- rI * L
    re <- rE * K
  
    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = 0, "I" = L - 1, "R" = 1),
      disease_progression_rates = c("I" = rI * L / (L- 1)),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0),
      malthusian_matching = FALSE
    )
  
    # Get a reference to the private environment
    private <- m$.__enclos_env__$private
  
    # Get a interpolation of the signal
    signal <- approxfun(incidence_signal[[model_configuration]]$t, incidence_signal[[model_configuration]]$incidence, method = "constant")
    
    m$set_forcing_functions(
      infected_forcing = \(t, infected) signal(t) / ri + infected, # If L = 1, infected is numeric(0)
      state_vector_forcing = function(t, dy_dt) {
        dy_dt[private$i1_state_indexes] <- dy_dt[private$i1_state_indexes] - 
          signal(t) # Use signal as forcing for inflow to I1
        return(dy_dt)
      } 
    )
  
    
    # Create the starting state vector and the constraints
    y0 <- c(rep(0, L - 1), 0, 1)
    y0 <- y0 / sum(y0)
    
    times <- seq(from = 0, to = t0)
    
    sol <- deSolve::ode(
      y = y0,
      times = times,
      func = private %.% rhs,
      parms = NULL
    )
    
    R <- sol[nrow(sol), 1 + (L - 1) + 1]
    S <- sol[nrow(sol), 1 + (L - 1) + 2]
    
    R <- R / (R  + S)
    S <- S / (R  + S)
    
    
    t <- synthetic_model[[model_configuration]][, 1]
    E <- synthetic_model[[model_configuration]][t == t0, 1 + seq_len(K)]
    I <- synthetic_model[[model_configuration]][t == t0, 1 + K + seq_len(L)]
  
    run_model(c(E, I), R, S, K, L, rE, rI, offset = 0, signal = "incidence", scale_EI = FALSE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }, .progress = TRUE) |>
    purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_incidence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_incidence_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

#### Scaling RS states
```{r, eval = run_SR_blocks}
simplified_incidence_fit_gg <- expand.grid(
  model_configuration = names(incidence_signal_derivatives),
  true_configuration  = names(incidence_signal_derivatives)
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....

    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]


    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    ri <- rI * L
    re <- rE * K

    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(rep(1, K + 1), 0, 0)
    y0 <- y0 / sum(y0)

    times <- seq(- 1 / rE, 0, length.out = 10)
    ss <- predict(incidence_polyfits[[true_configuration]], data.frame(t = times))


    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = 1, "R" = 1),
      disease_progression_rates = c("E" = re / K, "I" = ri),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0),
      malthusian_matching = FALSE
    )

    # Get a reference to the private environment
    private <- m$.__enclos_env__$private


    objective_function <- function(y) {
      sol <- deSolve::ode(
        y = y,
        times = times,
        func = private %.% rhs,
        parms = NULL
      )

      I1 <- sol[, K + 2]

      sum(ri * I1 - ss)^2
    }

    op <- optim(
      par = y0,
      fn = objective_function,
      method = "L-BFGS-B",
      lower = 0,
      control = list(factr = 1e-2 / .Machine$double.eps)
    )

    EI_states <- op$par[1:(K + 1)]

    if (L > 1) {
      I_l <- predict(incidence_polyfits[[true_configuration]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()
      EI_states <- c(EI_states, I_l)
    }

    run_model(EI_states, R, S, K, L, rE, rI, signal = "incidence", scale_EI = FALSE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }, .progress = TRUE) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_incidence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_incidence_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```





## Implementation: Prevalence signal

And now for the prevalence


### Initialising via solving the ODE of simplified system
```{r, eval = run_SR_blocks}
simplified_model_fit_gg <- purrr::map(names(prevalence_signal_derivatives), ~ {
  n_states <- as.numeric(stringr::str_extract_all(.x, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]

  ri <- rI * L
  re <- rE * K

  # Generate a uniform initial state_vector that sums to 1
  y0 <- c(rep(1, K + L), 0, 0)
  y0 <- y0 / sum(y0)

  times <- seq(- 1 / rE, 0, length.out = 10)
  ss <- predict(prevalence_polyfits[[.x]], data.frame(t = times))


  # Run a SIR model to generate the target of our initialisation
  m <- DiseasyModelOdeSeir$new(
    season = T, activity = T,
    observables = DiseasyObservables$new(
      conn = DBI::dbConnect(RSQLite::SQLite()),
      last_queryable_date = Sys.Date() - 1
    ),
    variant = DiseasyVariant$new(n_variants = 1),
    compartment_structure = c("E" = K, "I" = L, "R" = 1),
    disease_progression_rates = c("E" = re / K, "I" = ri),
    parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0),
    malthusian_matching = FALSE
  )

  # Get a reference to the private environment
  private <- m$.__enclos_env__$private

  objective_function <- function(y) {
    sol <- deSolve::ode(
      y = y,
      times = times,
      func = private %.% rhs,
      parms = NULL
    )

    I <- rowSums(sol[, (1 + K + 1):(1 + K + L), drop = FALSE])

    sum(I - ss)^2
  }

  op <- optim(
    par = y0,
    fn = objective_function,
    method = "L-BFGS-B",
    lower = 0
  )

  EI_states <- op$par[1:(K + 1)]

  if (L > 1) {
    I_l <- predict(prevalence_polyfits[[.x]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()
    EI_states <- c(EI_states, I_l)
  }

  t <- synthetic_model[[.x]][, 1]
  R <- synthetic_model[[.x]][t == t0, 1 + K + L + 1]
  S <- synthetic_model[[.x]][t == t0, 1 + K + L + 2]

  run_model(EI_states, R, S, K, L, rE, rI, signal = "prevalence", scale_EI = TRUE) |>
    dplyr::mutate(true_configuration = .x, model_configuration = .x)
}) |>
  purrr::list_rbind()


ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_line(data = exact_prevalence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_model_fit_gg, color = "red", linewidth = 1) +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

#### Scaling EI states
```{r, eval = run_SR_blocks}
simplified_prevalence_fit_gg <- expand.grid(
  model_configuration = names(prevalence_signal_derivatives),
  true_configuration  = names(prevalence_signal_derivatives)
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....

    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]


    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    ri <- rI * L
    re <- rE * K

    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(rep(1, K + 1), 0, 0)
    y0 <- y0 / sum(y0)

    times <- seq(- 1 / rE, 0, length.out = 10)
    ss <- predict(prevalence_polyfits[[true_configuration]], data.frame(t = times))


    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = 1, "R" = 1),
      disease_progression_rates = c("E" = re / K, "I" = ri),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0),
      malthusian_matching = FALSE
    )

    # Get a reference to the private environment
    private <- m$.__enclos_env__$private


    objective_function <- function(y) {
      sol <- deSolve::ode(
        y = y,
        times = times,
        func = private %.% rhs,
        parms = NULL
      )

      I1 <- sol[, K + 2]

      sum(ri * I1 - ss)^2
    }

    op <- optim(
      par = y0,
      fn = objective_function,
      method = "L-BFGS-B",
      lower = 0,
      control = list(factr = 1e-2 / .Machine$double.eps)
    )

    EI_states <- op$par[1:(K + 1)]

    if (L > 1) {
      I_l <- predict(prevalence_polyfits[[true_configuration]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()
      EI_states <- c(EI_states, I_l)
    }

    run_model(EI_states, R, S, K, L, rE, rI, signal = "prevalence", scale_EI = TRUE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }, .progress = TRUE) |>
  purrr::list_rbind()


ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_line(data = exact_prevalence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_prevalence_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```


#### Scaling RS states
```{r, eval = run_SR_blocks}
simplified_prevalence_fit_gg <- expand.grid(
  model_configuration = names(prevalence_signal_derivatives),
  true_configuration  = names(prevalence_signal_derivatives)
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....

    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]


    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    ri <- rI * L
    re <- rE * K

    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(rep(1, K + 1), 0, 0)
    y0 <- y0 / sum(y0)

    times <- seq(- 1 / rE, 0, length.out = 10)
    ss <- predict(prevalence_polyfits[[true_configuration]], data.frame(t = times))


    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = 1, "R" = 1),
      disease_progression_rates = c("E" = re / K, "I" = ri),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0),
      malthusian_matching = FALSE
    )

    # Get a reference to the private environment
    private <- m$.__enclos_env__$private


    objective_function <- function(y) {
      sol <- deSolve::ode(
        y = y,
        times = times,
        func = private %.% rhs,
        parms = NULL
      )

      I1 <- sol[, K + 2]

      sum(ri * I1 - ss)^2
    }

    op <- optim(
      par = y0,
      fn = objective_function,
      method = "L-BFGS-B",
      lower = 0,
      control = list(factr = 1e-2 / .Machine$double.eps)
    )

    EI_states <- op$par[1:(K + 1)]

    if (L > 1) {
      I_l <- predict(prevalence_polyfits[[true_configuration]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()
      EI_states <- c(EI_states, I_l)
    }

    run_model(EI_states, R, S, K, L, rE, rI, signal = "prevalence", scale_EI = FALSE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }, .progress = TRUE) |>
  purrr::list_rbind()


ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_line(data = exact_prevalence_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_prevalence_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

