---
title: "DiseasyImmunity manuscript"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
devtools::load_all()
```


```{r reset}
if (exists("im")) rm(im)
im <- DiseasyImmunity$new()

```


```{r define waning functions}

# We define our list of "raw" test functions
f <- list(
  "exponential" = \(t) exp(-t / time_scale),
  #"sigmoidal" = \(t) exp(-(t - time_scale) / 6) / (1 + exp(-(t - time_scale) / 6)),
  "heaviside" = \(t) as.numeric(t < time_scale),
  "exp_sum" = \(t) (exp(-t / time_scale) + exp(-2 * t / time_scale) + exp(-3 * t / time_scale)) / 3,
  "linear" = \(t) pmax(1 - t / time_scale, 0)
)
# And define a list of corresponding time_scales
t_f <- rep(20, length(f))

# Construct a list with a non-zero asymptote
g <- list(
  "exponential" = \(t) 0.2 + 0.8 * exp(-t / time_scale),
  #"sigmoidal" = \(t) 0.2 + 0.8 * exp(-(t - time_scale) / 6) / (1 + exp(-(t - time_scale) / 6)),
  "heaviside" = \(t) 0.2 + 0.8 * as.numeric(t < time_scale),
  "exp_sum" = \(t) (exp(-t / time_scale) + exp(-2 * t / time_scale) + exp(-3 * t / time_scale)) / 3,
  "linear" = \(t) 0.2 + 0.8 * pmax(1 - t / time_scale, 0)
)
t_g <- t_f

# Construct a list with double the time scale
h <- f
t_h <- t_f * 2


# Construct a list of all models
models <- c(f, g, h)
model_names <- c(paste0(names(f), "-0"), paste0(names(f), "-c"), paste0(names(f), "-2t"))
time_scales <- c(t_f, t_g, t_h)

zip <- function(...) mapply(list, ..., SIMPLIFY = FALSE)

```

We run a few examples to manually inspect the fitting
```{r manually check fits}
im$set_waning_model("linear_waning", target = "infection")
plot(im, method = "free_gamma", N = 3, optim_control = data.frame("method" = "nlm", "maxit" = 40))

im$approximate_compartmental(method = "free_delta", N = 3, optim_control = data.frame("method" = "nlm", "maxit" = 40))
```

```{r manually check fits}
im$set_waning_model("exponential_waning", time_scale = t_f[[1]], target = "infection")
plot(im, method = "free_gamma", N = 3)

im$approximate_compartmental(method = "free_delta", N = 2, optim_control = data.frame("method" = "nlm", "maxit" = 40))
```

```{r manually check fits}
im$set_waning_model("heaviside_waning", time_scale = t_f[[1]], target = "infection")
plot(im, method = "free_gamma", N = 3)

im$approximate_compartmental(method = "free_delta", N = 2, optim_control = data.frame("method" = "nlmm", "maxit" = 40))

```


```{r}
if (!exists("im1")) {
  im1 <- DiseasyImmunity$new()
}
fs <- list(
  "linear" = "linear_waning", 
  "exponential" = "exponential_waning", 
  #"sigmoidal" = "sigmoidal_waning", 
  "heaviside" = "heaviside_waning", 
  "sum_exponential" = f[["exp_sum"]])
methods <- c("free_delta", "free_gamma", "all_free")
N <- 3

combinations <- tidyr::expand_grid(fs, methods) |>
  dplyr::mutate("name_fs" = names(fs))

private <- im1$.__enclos_env__$private

approxes <- combinations |> 
  purrr::pmap( \(fs, methods, name_fs) {
    im1$set_waning_model(model = fs, target = "infection")
    out <- im1$approximate_compartmental(
      method = methods, 
      N = N, 
      optim_control = data.frame("method" = "nlm", "maxit" = 100),
      monotonous = FALSE, 
      individual_level = FALSE
    )
    out <- append(out, list("model" = im1$model[["infection"]], "time_scale" = unlist(private$get_time_scale())))
    out
  })

approxes_tt <- approxes |> 
  purrr::list_transpose() |>
  tibble::as_tibble() |>
  dplyr::mutate("fun" = combinations$name_fs) |>
  dplyr::select("fun", "method", tidyselect::everything())


t <- seq(from = 0, to = 60, length.out = 100)


approxes_gg <- approxes_tt |>
  dplyr::select("fun", "method", "N", "gamma", "delta", "execution_time", "sqrt_integral", "model", "convergence")


gg1 <- approxes_gg |>
  dplyr::transmute(
    .data$fun,
    "method" = factor(.data$method, levels = c("free_delta", "free_gamma", "all_free")),
    .data$model
  ) |>
  purrr::pmap( ~ {
    tibble::tibble(
      "fun" = ..1, 
      "method" = ..2, 
      "t" = !!t, 
      "y" = purrr::map_dbl(!!t, ..3),
      "type" = "target"
    )
  }) |>
  purrr::list_rbind()


gg2 <- approxes_gg |>
  dplyr::transmute(
    .data$fun,
    "method" = factor(.data$method, levels = c("free_delta", "free_gamma", "all_free")),
    .data$gamma,
    .data$delta
  ) |>
  purrr::pmap( ~ {
    tibble::tibble(
      "fun" = ..1, 
      "method" = ..2, 
      "t" = !!t, 
      "y" = purrr::map_dbl(!!t, private$get_approximation(..3, ..4, N)),
      "type" = "approximation"
    )
  }) |>
  purrr::list_rbind()


rbind(gg1, gg2) |>
  ggplot2::ggplot(ggplot2::aes(x = t, y = y, linetype = factor(.data$type, levels = c("target", "approximation")), linewidth = factor(.data$type, levels = c("target", "approximation")))) +
  ggplot2::geom_line() +
  ggplot2::labs(y = "", x = "time", linetype = "Type", linewidth = "Type") + 
  ggplot2::facet_grid(
    factor(.data$fun, levels = c("exponential", "sigmoidal", "heaviside", "linear", "sum_exponential")) ~ factor(.data$method, levels = c("free_delta", "free_gamma", "all_free"))) +
  # Add text labels with execution time and the integral error
  ggplot2::geom_text(
    data = dplyr::mutate(approxes_gg, "type" = NA),
    ggplot2::aes(label = paste("time =", round(execution_time, 2), "s")),
    x = 30, y = 0.9, hjust = 0, vjust = 0, size = 3, color = "black"
  ) + 
  ggplot2::geom_text(
    data = dplyr::mutate(approxes_gg, "type" = NA),
    ggplot2::aes(label = paste("obj =", round(sqrt_integral, 2))),
    x = 30, y = 0.75, hjust = 0, vjust = 0, size = 3, color = "black"
  ) + 
  # ggplot2::geom_text(
  #   data = dplyr::mutate(approxes_gg, "type" = NA),
  #   ggplot2::aes(label = paste("converged =", ifelse(convergence == 0, "T", "F"))),
  #   x = 30, y = 0.6, hjust = 0, vjust = 0, size = 3, color = "black"
  # ) +
  ggplot2::scale_linetype_discrete(na.translate = F) +
  ggplot2::scale_linewidth_discrete(range = c(0.5, 1), na.translate = F)

ggplot2::ggsave("plots-for-NordicMathEpi-1.png", width = 7, height = 5)
```


```{r}
if (!exists("im2")) {
  im2 <- DiseasyImmunity$new()
}
fs <- list(
  "linear" = "linear_waning", 
  "exponential" = "exponential_waning", 
  #"sigmoidal" = "sigmoidal_waning", 
  "heaviside" = "heaviside_waning", 
  "sum_exponential" = f[["exp_sum"]]
)
methods <- c("free_delta", "free_gamma", "all_free")
N <- 3

combinations <- tidyr::expand_grid(fs, methods) |>
  dplyr::mutate("name_fs" = names(fs))

private <- im2$.__enclos_env__$private

approxes <- combinations |> 
  purrr::pmap( \(fs, methods, name_fs) {
    im2$set_waning_model(model = fs, target = "infection")
    im2$set_waning_model(model = fs, time_scale = 40, target = "hospitalisation")
    out <- im2$approximate_compartmental(
      method = methods, 
      N = N, 
      optim_control = data.frame("method" = "nlm", "maxit" = 100),
      monotonous = FALSE, 
      individual_level = FALSE
    )
    out <- append(out, list("model_1" = im2$model[["infection"]], "model_2" = im2$model[["hospitalisation"]], "time_scale" = unlist(private$get_time_scale())))
    out
  })

approxes_tt <- approxes |> 
  purrr::list_transpose() |>
  tibble::as_tibble() |>
  dplyr::mutate("fun" = combinations$name_fs) |>
  dplyr::select("fun", "method", tidyselect::everything())


t <- seq(from = 0, to = 60, length.out = 100)


approxes_gg <- approxes_tt |>
  dplyr::select("fun", "method", "N", "gamma", "delta", "execution_time", "sqrt_integral", "model_1", "model_2", "convergence")


gg1 <- approxes_gg |>
  dplyr::transmute(
    .data$fun,
    "method" = factor(.data$method, levels = c("free_delta", "free_gamma", "all_free")),
    .data$model_1,
    .data$model_2
  ) |>
  purrr::pmap( ~ {
    tibble::tibble(
      "fun" = ..1, 
      "method" = ..2, 
      "t" = !!t, 
      "y_infection" = purrr::map_dbl(!!t, ..3),
      "y_hospitalisation" = purrr::map_dbl(!!t, ..4),
      "type" = "target"
    )
  }) |>
  purrr::list_rbind() |>
  tidyr::pivot_longer(
    cols = dplyr::starts_with("y_"), 
    names_prefix = "y_", 
    names_to = "target",
    values_to = "y"
  )

ggplot2::ggplot(gg1, ggplot2::aes(x = t, y = y, linetype = target)) +
  ggplot2::geom_line() +
  ggplot2::labs(y = "Target value") + 
  ggplot2::facet_grid(fun ~ method)


gg2 <- approxes_gg |>
  dplyr::transmute(
    .data$fun,
    "method" = factor(.data$method, levels = c("free_delta", "free_gamma", "all_free")),
    .data$gamma,
    .data$delta
  ) |>
  purrr::pmap( ~ {
    tibble::tibble(
      "fun" = ..1, 
      "method" = ..2, 
      "t" = !!t, 
      "y_infection" = purrr::map_dbl(!!t, private$get_approximation(..3[["infection"]], ..4, N)),
      "y_hospitalisation" = purrr::map_dbl(!!t, private$get_approximation(..3[["hospitalisation"]], ..4, N)),
      "type" = "approximation"
    )
  }) |>
  purrr::list_rbind() |>
  tidyr::pivot_longer(
    cols = dplyr::starts_with("y_"), 
    names_prefix = "y_", 
    names_to = "target",
    values_to = "y"
  )
  
ggplot2::ggplot(gg2, ggplot2::aes(x = t, y = y, linetype = target)) +
  ggplot2::geom_line() +
  ggplot2::labs(y = "Target value") + 
  ggplot2::facet_grid(fun ~ method)  


rbind(gg1, gg2) |>
  ggplot2::ggplot(ggplot2::aes(x = t, y = y, color = target, linetype = factor(.data$type, levels = c("target", "approximation")), linewidth = factor(.data$type, levels = c("target", "approximation")))) +
  ggplot2::geom_line() +
  ggplot2::labs(y = "", x = "time", linetype = "Type", linewidth = "Type", color = "Target") + 
  ggplot2::facet_grid(
    factor(.data$fun, levels = c("exponential", "sigmoidal", "heaviside", "linear", "sum_exponential")) ~ factor(.data$method, levels = c("free_delta", "free_gamma", "all_free"))) +
  # Add text labels with execution time and the integral error
  ggplot2::geom_text(
    data = dplyr::mutate(approxes_gg, "type" = NA),
    ggplot2::aes(label = paste("time =", round(execution_time, 2), "s")),
    x = 30, y = 0.9, hjust = 0, vjust = 0, size = 3, color = "black"
  ) + 
  ggplot2::geom_text(
    data = dplyr::mutate(approxes_gg, "type" = NA),
    ggplot2::aes(label = paste("obj =", round(sqrt_integral, 2))),
    x = 30, y = 0.75, hjust = 0, vjust = 0, size = 3, color = "black"
  ) + 
  # ggplot2::geom_text(
  #   data = dplyr::mutate(approxes_gg, "type" = NA),
  #   ggplot2::aes(label = paste("converged =", ifelse(convergence == 0, "T", "F"))),
  #   x = 30, y = 0.6, hjust = 0, vjust = 0, size = 3, color = "black"
  # ) +
  ggplot2::scale_linetype_discrete(na.translate = F) + 
  ggplot2::scale_linewidth_discrete(range = c(0.5, 1), na.translate = F)

ggplot2::ggsave("plots-for-NordicMathEpi-2.png", width = 7, height = 5)
```






```{r}
if (!exists("im3")) {
  im3 <- DiseasyImmunity$new()
}
fs <- "exponential_waning"
method <- "free_delta"
N <- 3

im3$set_waning_model(model = fs, target = "infection")
im3$set_waning_model(model = fs, time_scale = 40, target = "hospitalisation")


self <- im3
private <- im3$.__enclos_env__$private


n_free_parameters <- N - 1

p_01 <- \(p) 1 / (1 + exp(-p)) # Sigmoid mapping of parameters from -Inf / Inf to 0 / 1
p_0inf <- \(p) log(1 + exp(p)) # Mapping of parameters from -Inf / Inf to 0 / Inf ("Softplus" function)

par_to_delta <- \(par) p_0inf(par) # All parameters are delta
par_to_gamma <- \(par, model_id, f_inf) seq(from = 1, to = f_inf, length.out = N) # gammas: 1 to f_inf

monotonous <- individual_level <- TRUE

# For the optimisation, we define the objective function which loops over each model and computes the total
# square deviation from the target.
# The error is then the sum of these deviations across models
obj_function <- function(par) {

  metrics <- purrr::map(seq_along(self$model), \(model_id) {

    delta <- par_to_delta(par)
    gamma <- par_to_gamma(par, model_id, self$model[[model_id]](Inf))

    # Some optimisers yield non-finite delta
    if (any(is.infinite(delta)) || anyNA(delta) || anyNA(gamma)) {

      # We define the objective function as infinite in this case
      return(list("value" = 1 / .Machine$double.eps, "penalty" = 1 / .Machine$double.eps))

    } else {

      approx <- private$get_approximation(gamma, delta, N)

      # Finds diff from approximation and target function
      integrand <- \(t) (approx(t) - self$model[[model_id]](t))^2

      # Numerically integrate the differences
      value <- tryCatch(
        sqrt(stats::integrate(integrand, lower = 0, upper = Inf)$value),
        error = function(e) {
          1 / (min(delta) + .Machine$double.eps) # If the any delta is too small, the integral looks divergent
          # (since we too approach the asymptote too slowly).
          # We use the 1 / delta to create a wall in the optimisation
        }
      )


      # Penalise non-monotone solutions
      penalty <- monotonous * sum(purrr::keep(diff(gamma), ~ . > 0))

      # Penalise spread of gamma
      penalty <- penalty + individual_level * sd(gamma)

      return(list("value" = value, "penalty" = penalty))
    }
  }) |>
    purrr::list_transpose()

  return(metrics)
}


K <- 25
combinations <- tidyr::expand_grid(
  p1 = seq(from = -1, to = -4, length.out = K),
  p2 = seq(from = -2, to = -5, length.out = K)
) 

values <- purrr::pmap(
  combinations, 
  \(p1, p2) purrr::pluck(obj_function(c(p1, p2)), "value")
)

results <- combinations |> 
  dplyr::mutate(
    value_infection = purrr::map_dbl(values, ~ purrr::pluck(., 1)),
    value_hospitalisation = purrr::map_dbl(values, ~ purrr::pluck(., 2)),
    value_total = value_infection + value_hospitalisation
  ) |>
  tidyr::pivot_longer(
    cols = dplyr::starts_with("value_"), 
    names_prefix = "value_", 
    names_to = "target",
    values_to = "value"
  )

# Plot the results as a color map
# Convert the x and y ticks to the original scale
ggplot2::ggplot(results, ggplot2::aes(x = p1, y = p2, z = value, fill = log(value))) +
  ggplot2::geom_tile() +
  #ggplot2::geom_contour(bins = 100) + 
  #ggplot2::scale_fill_viridis_c() +
  ggplot2::scale_fill_gradientn(colours = RColorBrewer::brewer.pal(7, "RdBu")) + 
  ggplot2::facet_wrap(~ target) +
  ggplot2::labs(x = "p1", y = "p2", fill = "log(obj)")
  


ggplot2::ggsave("plots-for-NordicMathEpi-3.png", width = 7, height = 5)
```

```{r}

combinations |> 
  dplyr::distinct(p2)

results |> 
  dplyr::filter(p2 == -3.5) |>
  ggplot2::ggplot(ggplot2::aes(x = p1, y = value, color = target)) +
  ggplot2::geom_line()
  


# Plot the results as a color map
# Convert the x and y ticks to the original scale
ggplot2::ggplot(dplyr::filter(results, target == "total", value < 1.85), ggplot2::aes(x = p1, y = p2, z = value, fill = log(value))) +
  ggplot2::geom_tile() +
  #ggplot2::geom_contour(bins = 100) + 
  #ggplot2::scale_fill_viridis_c() +
  ggplot2::scale_fill_gradientn(colours = RColorBrewer::brewer.pal(7, "RdBu")) + 
  ggplot2::facet_wrap(~ target) +
  ggplot2::labs(x = "p1", y = "p2", fill = "log(obj)")

```







```{r}
if (!exists("im4")) {
  im4 <- DiseasyImmunity$new()
}

# For the optimisation, we define the objective function which loops over each model and computes the total
# square deviation from the target.
# The error is then the sum of these deviations across models
obj_function <- function(par, par_to_delta, par_to_gamma) {

  metrics <- purrr::map(seq_along(self$model), \(model_id) {

    delta <- par_to_delta(par)
    gamma <- par_to_gamma(par, model_id, self$model[[model_id]](Inf))

    # Some optimisers yield non-finite delta
    if (any(is.infinite(delta)) || anyNA(delta) || anyNA(gamma)) {

      # We define the objective function as infinite in this case
      return(list("value" = 1 / .Machine$double.eps, "penalty" = 1 / .Machine$double.eps))

    } else {

      approx <- private$get_approximation(gamma, delta, N)

      # Finds diff from approximation and target function
      integrand <- \(t) (approx(t) - self$model[[model_id]](t))^2

      # Numerically integrate the differences
      value <- tryCatch(
        sqrt(stats::integrate(integrand, lower = 0, upper = Inf)$value),
        error = function(e) {
          1 / (min(delta) + .Machine$double.eps) # If the any delta is too small, the integral looks divergent
          # (since we too approach the asymptote too slowly).
          # We use the 1 / delta to create a wall in the optimisation
        }
      )


      # Penalise non-monotone solutions
      penalty <- monotonous * sum(purrr::keep(diff(gamma), ~ . > 0))

      # Penalise spread of gamma
      penalty <- penalty + individual_level * sd(gamma)

      return(list("value" = value, "penalty" = penalty))
    }
  }) |>
    purrr::list_transpose()

  return(metrics)
}



im4$set_waning_model(model = "exponential_waning", target = "infection")
self <- im4
private <- im4$.__enclos_env__$private


N <- 3
n_models <- 1
monotonous <- individual_level <- FALSE


p_01 <- \(p) 1 / (1 + exp(-p)) # Sigmoid mapping of parameters from -Inf / Inf to 0 / 1
p_0inf <- \(p) log(1 + exp(p)) # Mapping of parameters from -Inf / Inf to 0 / Inf ("Softplus" function)


# Free gamma
n_free_parameters <- (N - 1) * n_models + 1
par_to_delta <- \(par) p_0inf(par[-seq_len(n_free_parameters - 1)]) # Last parameter is delta
par_to_gamma <- \(par, model_id, f_inf) {
  c(
    p_01(par[seq_len(N - 1) + (model_id - 1) * (N - 1)]), # The gamma parameters of the n'th model
    f_inf # And inject the fixed end-point
  )
}

obj_function(c(-1, -1, -3, -3), par_to_delta, par_to_gamma)


# All free
n_free_parameters <- (N - 1) * n_models + N - 1
par_to_delta <- \(par) p_0inf(par[-seq_len(n_free_parameters - (N - 1))]) # Last N-1 parameters are the deltas
par_to_gamma <- \(par, model_id, f_inf) {
  c(
    p_01(par[seq_len(N - 1) + (model_id - 1) * (N - 1)]), # The gamma parameters of the n'th model
    f_inf # And inject the fixed end-point
  )
}

obj_function(c(-1, -1, -3), par_to_delta, par_to_gamma)

```
 
