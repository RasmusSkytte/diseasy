---
title: "DiseasyImmunity manuscript"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(diseasy)
```


```{r reset}
devtools::load_all()

if (exists("im")) rm(im)
im <- DiseasyImmunity$new()

```

```{r define waning functions}

# We define our list of "raw" test functions
f <- list(
  #"exponential" = \(t) exp(-t / time_scale),
  "sigmoidal" = \(t) exp(-(t - time_scale) / 6) / (1 + exp(-(t - time_scale) / 6)),
  #"heaviside" = \(t) as.numeric(t < time_scale),
  "exp_sum" = \(t) (exp(-t / time_scale) + exp(-2 * t / time_scale) + exp(-3 * t / time_scale)) / 3,
  "linear" = \(t) pmax(1 - t / time_scale, 0)
)
# And define a list of corresponding time_scales
t_f <- rep(20, length(f))

# Construct a list with a non-zero asymptote
g <- list(
  #"exponential" = \(t) 0.2 + 0.8 * exp(-t / time_scale),
  "sigmoidal" = \(t) 0.2 + 0.8 * exp(-(t - time_scale) / 6) / (1 + exp(-(t - time_scale) / 6)),
  #"heaviside" = \(t) 0.2 + 0.8 * as.numeric(t < time_scale),
  "exp_sum" = \(t) (exp(-t / time_scale) + exp(-2 * t / time_scale) + exp(-3 * t / time_scale)) / 3,
  "linear" = \(t) 0.2 + 0.8 * pmax(1 - t / time_scale, 0)
)
t_g <- t_f

# Construct a list with double the time scale
h <- f
t_h <- t_f * 2


# Construct a list of all models
models <- c(f, g, h)
model_names <- c(paste0(names(f), "-0"), paste0(names(f), "-c"), paste0(names(f), "-2t"))
time_scales <- c(t_f, t_g, t_h)

zip <- function(...) mapply(list, ..., SIMPLIFY = FALSE)

```

```{r manually check fits}
im$set_waning_model(f[["linear"]], time_scale = t_f[[1]], target = "infection")
plot(im, method = "free_gamma", N = 3)

im$approximate_compartmental(method = "free_gamma", N = 3)
```

```{r manually check fits}
im$set_waning_model(f[["linear"]], time_scale = t_f[[1]], target = "infection")
plot(im, method = "all_free", N = 3)

im$approximate_compartmental(method = "all_free", N = 3)
```

```{r run all single targets}
cache <- cachem::cache_disk(dir = devtools::package_file("vignettes/articles/article_data/single"))

# Set the combinations to test
combinations_single <- tidyr::expand_grid(
  model = zip(models, model_names, time_scales),
  method = c("free_gamma", "free_delta", "all_free")
)

future::plan("sequential")
#future::plan("multisession")

# Run the approximations and note the convergence point
combinations <- combinations_single |>
  purrr::pmap(~ zip(list(..1), ..2))

N_max <- 10                                                                                                             # nolint: object_name_linter


progressr::with_progress({
  p <- progressr::progressor(steps = length(combinations) * N_max)

  invisible(future.apply::future_lapply(
    combinations,
    future.seed = TRUE,
    FUN = \(combination) {

      N <- seq(from = 2, to = N_max, by = 1)                                                                            # nolint: object_name_linter

      # Unpack model
      model_zip <- combination[[1]][[1]]
      method <- combination[[1]][[2]]

      model <- model_zip[[1]]
      model_name <- model_zip[[2]]
      time_scale <- model_zip[[3]]

      im_p <- DiseasyImmunity$new()

      # Generate approximations and store them and the convergence point
      for (n in seq_along(N)) {
        set.seed(n) # Not sure where a random seed is used, but future_lapply detects a call to rng

        # Get the results up until now
        current_approxes <- cache$get(key = glue::glue("{model_name}-{method}"))

        # Compute next values
        if (!(N[n] %in% names(current_approxes))) {

          # Set the target and approximate
          im_p$set_waning_model(model, time_scale = time_scale, target = "infection")
          approx <- im_p$approximate_compartmental(method = method, N = N[n])

          # Append to existing results
          if (cachem::is.key_missing(current_approxes)) {
            current_approxes <- list()
          }
          current_approxes <- modifyList(current_approxes, stats::setNames(list(approx), N[n]))

          # Store to cache
          cache$set(key = glue::glue("{model_name}-{method}"), current_approxes)
        }

        p()
      }

      rm(im_p)
    }
  ))
})
```

```{r check monotonicity in solution}
non_monotonicity_single <- combinations_single |>
  purrr::pmap(
    .progress = interactive(),
    .f = \(model_zip, method) {

      # Unpack model
      model <- model_zip[[1]]
      model_name <- model_zip[[2]]
      time_scale <- model_zip[[3]]

      # Check if we have already computed this value
      current_approxes <- cache$get(key = glue::glue("{model_name}-{method}"))
      if (cachem::is.key_missing(current_approxes)) {
        return(NULL)
      } else {
        monotoncity <- current_approxes |>
          purrr::list_transpose() |>
          tibble::as_tibble() |>
          dplyr::transmute(
            "model" = !!model_name,
            .data$method,
            .data$N,
            .data$gamma,
            "monotone" = purrr::map_lgl(.data$gamma, ~ all(diff(.) <= 0))
          )
        return(monotoncity)
      }
    }
  ) |>
  purrr::list_rbind()

non_monotonicity_single |>
  dplyr::filter(!.data$monotone)
```

```{r detect single target convergence}
convergence_single <- combinations_single |>
  purrr::pmap_dbl(
    .progress = interactive(),
    .f = \(model_zip, method) {

      # Unpack model
      model <- model_zip[[1]]
      model_name <- model_zip[[2]]
      time_scale <- model_zip[[3]]

      # Get the results
      current_approxes <- cache$get(key = glue::glue("{model_name}-{method}"))

      # Check if approximation has converged
      prev_values <- purrr::map_dbl(current_approxes, ~ purrr::pluck(., "value")) |>
        tibble::enframe(name = "N", value = "value") |>
        dplyr::mutate("N" = as.numeric(N))

      # Look for the N that caused convergence using Kneedle algorithm
      N_converged <- tryCatch(                                                                                          # nolint: object_name_linter
        kneedle::kneedle(
          x = prev_values$N,
          y = prev_values$value,
          decreasing = TRUE,
          concave = FALSE,
          sensitivity = 1
        ),
        error = function(e) numeric(0)
      ) |>
        purrr::pluck(1, .default = numeric(0))

      # In some cases, values are increasing not decreasing, so we manually detect these
      # (We allow a small increase to account for numerical imprecision)
      detect_increase <- \(x) (x - cummin(x)) > 1e-3 * cummin(x)
      if (identical(N_converged, numeric(0)) && any(detect_increase(prev_values$value))) {
        N_converged <- prev_values$N[[which(detect_increase(prev_values$value))[1]]]                                    # nolint: object_name_linter
      }

      return(ifelse(identical(N_converged, numeric(0)), NA, N_converged))
    }
  ) |>
  tibble::tibble(
    "model" = purrr::map_chr(combinations_single$model, ~ purrr::pluck(., 2)),
    "method" = combinations_single$method,
    "N" = _
  )
```

```{r elbow curve single target}
metrics_single <- combinations_single |>
  purrr::pmap(
    .progress = interactive(),
    .f = \(model_zip, method) {

      # Unpack model
      model <- model_zip[[1]]
      model_name <- model_zip[[2]]
      time_scale <- model_zip[[3]]

      # Check if we have already computed this value
      current_approxes <- cache$get(key = glue::glue("{model_name}-{method}"))
      if (cachem::is.key_missing(current_approxes)) {
        metrics <- data.frame(
          "model" = model_name,
          "method" = method,
          "N" = NA,
          "value" = NA,
          "execution_time" = NA
        )
      } else {
        metrics <- current_approxes |>
          purrr::list_transpose() |>
          tibble::as_tibble() |>
          dplyr::transmute("model" = !!model_name, "method" = !!method, .data$N, .data$value, .data$execution_time)
      }

      return(metrics)
    }
  ) |>
  purrr::list_rbind()


# Prepare for plotting
metrics_single_gg <- metrics_single |>
  dplyr::mutate("execution_time" = as.numeric(.data$execution_time)) |>
  tidyr::separate_wider_delim("model", delim = "-", names = c("model", "variant"), too_few = "align_start") |>
  dplyr::mutate("variant" = dplyr::case_when(
    variant == "0" ~ "base",
    variant == "c" ~ "non-zero asymptote",
    variant == "2t" ~ "twice the time scale"
  )) |>
  dplyr::filter(!is.na(value)) |>
  tidyr::pivot_longer(!c("model", "variant", "method", "N"), names_to = "metric")

convergence_single_gg <- convergence_single |>
  tidyr::separate_wider_delim("model", delim = "-", names = c("model", "variant"), too_few = "align_start") |>
  dplyr::mutate(
    "variant" = dplyr::case_when(
      variant == "0" ~ "base",
      variant == "c" ~ "non-zero asymptote",
      variant == "2t" ~ "twice the time scale"
    )
  )

# Plot
ggplot2::ggplot(metrics_single_gg, ggplot2::aes(x = N, y = value, color = method, linetype = variant)) +
  ggplot2::geom_line(linewidth = 1) +
  ggplot2::geom_point() +
  ggplot2::scale_y_log10() +
  ggplot2::facet_grid(metric ~ model, scales = "free") +
  ggplot2::labs(x = "N", y = "Metric") +
  ggplot2::theme_bw()
```

```{r}
metrics_single_gg |>
  dplyr::filter(.data$metric == "value") |>
  ggplot2::ggplot(ggplot2::aes(x = N, y = value, color = method)) +
  ggplot2::geom_line(linewidth = 1) +
  ggplot2::geom_point() +
  ggplot2::geom_vline(data = convergence_single_gg, ggplot2::aes(xintercept = N, linetype = method, color = method)) +
  ggplot2::facet_grid(model ~ variant, scales = "free") +
  ggplot2::labs(x = "N", y = "Value") +
  ggplot2::theme_bw()
```

```{r debug}
purrr::pluck(cache$get(key = glue::glue("sigmoidal-free_delta")), "3")
```

```{r debug}
metrics_single |>
  dplyr::filter(.data$model == "sigmoidal", .data$method == "free_delta")
```

```{r debug}
metrics_single_gg |>
  dplyr::filter(.data$model == "sigmoidal", .data$variant == "base", .data$method == "free_delta")
```


```{r manually check fits}
im$set_waning_model(f[["sigmoidal"]], time_scale = t_f[[1]], target = "infection")
im$set_waning_model(f[["sigmoidal"]], time_scale = t_f[[1]], target = "hospitalisation")
plot(im, method = "free_delta", N = 3)

im$approximate_compartmental(method = "free_delta", N = 3)
```
```{r manually check fits}
im$set_waning_model(h[["sigmoidal"]], time_scale = t_h[[1]], target = "infection")
im$set_waning_model(h[["sigmoidal"]], time_scale = t_h[[1]], target = "hospitalisation")
plot(im, method = "free_delta", N = 3)

im$approximate_compartmental(method = "free_delta", N = 3)
```


```{r run all double targets}
cache <- cachem::cache_disk(dir = devtools::package_file("vignettes/articles/article_data/double"))

# Set the combinations to test
combinations_double <- tidyr::expand_grid(
  model1 = zip(models, model_names, time_scales),
  model2 = zip(models, model_names, time_scales),
  method = c("free_gamma", "free_delta", "all_free")
)

#future::plan("sequential")
future::plan("multisession")#, workers = 4)

# Run the approximations and note the convergence point
combinations <- combinations_double |>
  purrr::pmap(~ zip(list(..1), list(..2), ..3))

N_max <- 10                                                                                                             # nolint: object_name_linter

progressr::with_progress({
  p <- progressr::progressor(steps = length(combinations) * N_max)

  invisible(future.apply::future_lapply(
    combinations,
    future.seed = TRUE,
    FUN = \(combination) {

      N <- seq(from = 2, to = N_max, by = 1)                                                                             # nolint: object_name_linter

      # Unpack model
      model1_zip <- combination[[1]][[1]]
      model2_zip <- combination[[1]][[2]]
      method <- combination[[1]][[3]]

      model1 <- model1_zip[[1]]
      model1_name <- model1_zip[[2]]
      time_scale1 <- model1_zip[[3]]

      model2 <- model2_zip[[1]]
      model2_name <- model2_zip[[2]]
      time_scale2 <- model2_zip[[3]]

      im_p <- DiseasyImmunity$new()

      # Generate approximations and store them and the convergence point
      for (n in seq_along(N)) {
        set.seed(n) # Not sure where a random seed is used, but future_lapply detects a call to rng

        # Get the results up until now
        current_approxes <- cache$get(key = glue::glue("{model1_name}-{model2_name}-{method}"))

        # Compute next values
        if (!(N[n] %in% names(current_approxes))) {

          # Set the target and approximate
          im_p$set_waning_model(model1, time_scale = time_scale1, target = "infection")
          im_p$set_waning_model(model2, time_scale = time_scale2, target = "hospitalisation")
          approx <- im_p$approximate_compartmental(method = method, N = N[n])

          # Append to existing results
          if (cachem::is.key_missing(current_approxes)) {
            current_approxes <- list()
          }
          current_approxes <- modifyList(current_approxes, stats::setNames(list(approx), N[n]))

          # Store to cache
          cache$set(key = glue::glue("{model1_name}-{model2_name}-{method}"), current_approxes)
        }

        p()
      }

      rm(im_p)
    }
  ))
})
```

```{r detect double target convergence}
convergence_double <- combinations_double |>
  purrr::pmap(
    .progress = interactive(),
    .f = \(model1_zip, model2_zip, method) {

      # Unpack model
      model1 <- model1_zip[[1]]
      model1_name <- model1_zip[[2]]
      time_scale1 <- model1_zip[[3]]

      model2 <- model2_zip[[1]]
      model2_name <- model2_zip[[2]]
      time_scale2 <- model2_zip[[3]]

      # Get the results
      current_approxes <- cache$get(key = glue::glue("{model1_name}-{model2_name}-{method}"))


      # Check if approximation has converged
      prev_values <- purrr::map_dbl(current_approxes, ~ purrr::pluck(., "value")) |>
        tibble::enframe(name = "N", value = "value") |>
        dplyr::mutate("N" = as.numeric(N))

      # Look for the N that caused convergence using kneedle algorithm
      N_converged <- tryCatch(                                                                                          # nolint: object_name_linter
        kneedle::kneedle(
          x = prev_values$N,
          y = prev_values$value,
          decreasing = TRUE,
          concave = FALSE,
          sensitivity = 1
        ),
        error = function(e) numeric(0)
      ) |>
        purrr::pluck(1, .default = numeric(0))

      # In some cases, values are increasing not decreasing, so we manually detect these
      # (We allow a small increase to account for numerical imprecision)
      detect_increase <- \(x) (x - cummin(x)) > 1e-3 *  cummin(x)
      if (identical(N_converged, numeric(0)) && any(detect_increase(prev_values$value))) {
        N_converged <- prev_values$N[[which(detect_increase(prev_values$value))[1]]]                                    # nolint: object_name_linter
      }

      return(ifelse(identical(N_converged, numeric(0)), NA, N_converged))
    }
  ) |>
  tibble::tibble(
    "model_1" = purrr::map_chr(combinations_double$model1, ~ purrr::pluck(., 2)),
    "model_2" = purrr::map_chr(combinations_double$model2, ~ purrr::pluck(., 2)),
    "method" = combinations_double$method,
    "N" = _
  )
```

```{r elbow curve double target}
metrics_double <- combinations_double |>
  purrr::pmap(
    .progress = interactive(),
    .f = \(model1_zip, model2_zip, method) {

      # Unpack model
      model1 <- model1_zip[[1]]
      model1_name <- model1_zip[[2]]
      time_scale1 <- model1_zip[[3]]

      model2 <- model2_zip[[1]]
      model2_name <- model2_zip[[2]]
      time_scale2 <- model2_zip[[3]]

      # Check if we have already computed this value
      current_approxes <- cache$get(key = glue::glue("{model1_name}-{model2_name}-{method}"))
      if (cachem::is.key_missing(approx)) {
        metrics <- data.frame(
          "model" = !!paste(model1_name, model2_name, sep = "/"),                                                       # nolint: paste_linter
          "method" = method,
          "N" = NA,
          "value" = NA,
          "execution_time" = NA
        )
      } else {
        metrics <- current_approxes |>
          purrr::list_transpose() |>
          tibble::as_tibble() |>
          dplyr::transmute(
            "model" = !!paste(model1_name, model2_name, sep = "/"),                                                     # nolint: paste_linter
            "method" = !!method,
            .data$N,
            .data$value,
            .data$execution_time
          )
      }

      return(metrics)
    }
  ) |>
  purrr::list_rbind()


# Prepare for plotting
metrics_double_gg <- metrics_double |>
  dplyr::inner_join(
    data.frame(
      "model" = c(
        #"exp_sum-0/exp_sum-0",
        "sigmoidal-0/sigmoidal-0",
        #"exp_sum-0/sigmoidal-0",
        "sigmoidal-2t/sigmoidal-2t"#,
        #"exp_sum-0/exp_sum-2t"
      )
    ),
    by = "model"
  ) |>
  dplyr::mutate("execution_time" = as.numeric(.data$execution_time)) |>
  dplyr::filter(!is.na(value)) |>
  tidyr::pivot_longer(!c("model", "method", "N"), names_to = "metric")

convergence_double_gg <- convergence_double |>
  tidyr::unite("model", c("model_1", "model_2"), sep = "/")


# Plot
ggplot2::ggplot(metrics_double_gg, ggplot2::aes(x = N, y = value, color = method)) +
  ggplot2::geom_line(linewidth = 1) +
  ggplot2::geom_point() +
  #ggplot2::scale_y_log10() +
  ggplot2::facet_grid(metric ~ model, scales = "free") +
  ggplot2::labs(x = "N", y = "Metric") +
  ggplot2::theme_bw()
```



```{r}
metrics_double_gg <- metrics_double |>
  dplyr::filter(N == 10) |>
  tidyr::separate_wider_delim("model", delim = "/", names = c("target_1", "target_2")) |>
  dplyr::mutate(
    "target_1" = factor(.data$target_1, levels = model_names),
    "target_2" = factor(.data$target_2, levels = model_names)
  )

metrics_double_gg |>
  ggplot2::ggplot(ggplot2::aes(x = target_1, y = target_2, fill = value)) +
  ggplot2::geom_tile() +
  ggplot2::facet_wrap(~ method) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, vjust = 0.5))

grid::grid.text("f", x = grid::unit(0.91, "npc"), y = grid::unit(0.80, "npc"))
```
