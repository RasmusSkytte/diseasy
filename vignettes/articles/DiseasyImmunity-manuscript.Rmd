---
title: "DiseasyImmunity manuscript"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(diseasy)
```


```{r reset}
devtools::load_all()

if (exists("im")) rm(im)
im <- DiseasyImmunity$new()

```

```{r define waning functions}

# We define our list of "raw" test functions
f = list(
  "exponential" = \(t) exp(-t / time_scale),
  "sigmoidal" = \(t) exp(-(t - time_scale) / 6) / (1 + exp(-(t - time_scale) / 6)),
  "heaviside" = \(t) as.numeric(t < time_scale),
  "exp_sum" = \(t) (exp(-t / time_scale) + exp(-2 * t / time_scale) + exp(-3 * t / time_scale)) / 3,
  "linear" = \(t) pmax(1 - t / time_scale, 0)
)
# And define a list of corresponding time_scales
t_f <- rep(20, length(f))

# Construct a list with a non-zero asymptote
g = list(
  "exponential" = \(t) 0.2 + 0.8 * exp(-t / time_scale),
  "sigmoidal" = \(t) 0.2 + 0.8 * exp(-(t - time_scale) / 6) / (1 + exp(-(t - time_scale) / 6)),
  "heaviside" = \(t) 0.2 + 0.8 * as.numeric(t < time_scale),
  "exp_sum" = \(t) (exp(-t / time_scale) + exp(-2 * t / time_scale) + exp(-3 * t / time_scale)) / 3,
  "linear" = \(t) 0.2 + 0.8 * pmax(1 - t / time_scale, 0)
)
t_g <- t_f

# Construct a list with double the time scale
h <- f
t_h <- t_f * 2


# Construct a list of all models
models <- c(f, g, h)
model_names <- c(names(f), paste0(names(f), "-c"), paste0(names(f), "-2t"))
time_scales <- c(t_f, t_g, t_h)

zip <- function(...) mapply(list, ..., SIMPLIFY = FALSE)

```


```{r manually check fits}
im$set_waning_model(g[["sigmoidal"]], time_scale = t_g[[1]], target = "infection")
plot(im, method = "free_gamma", N = 3)

im$approximate_compartmental(method = "free_gamma", N = 3)
```

```{r manually check fits}
im$set_waning_model(g[["exponential"]], time_scale = t_g[[1]], target = "infection")
plot(im, method = "all_free", N = 3)

im$approximate_compartmental(method = "free_delta", N = 4)
```


```{r run all single targets}
cache <- cachem::cache_disk(dir = devtools::package_file("vignettes/articles/article_data/single"))

# Set the combinations to test
combinations_single <- tidyr::expand_grid(
  model = zip(models, model_names, time_scales),
  method = c("free_gamma", "free_delta", "all_free")
)

#future::plan("sequential")
#future::plan("multisession")

# Run the approximations and note the convergence point
combinations_single |>
  #furrr::future_pwalk(
  purrr::pwalk(
    .progress = interactive(),
    #.options = furrr::furrr_options("seed" = TRUE),
    .f = \(model_zip, method) {

      N = seq(from = 2, to = 10, by = 1)

      # Unpack model
      model <- model_zip[[1]]
      model_name <- model_zip[[2]]
      time_scale <- model_zip[[3]]

      # Place holder for the convergence value
      N_converged <- numeric(0)

      # Generate approximations and store them and the convergence point
      for (n in seq_along(N)) {

        # Get the results up until now
        current_approxes <- cache$get(key = glue::glue("{model_name}-{method}"))

        # Compute next values
        if (!(N[n] %in% names(current_approxes))) {

          # Set the target and approximate
          im$set_waning_model(model, time_scale = time_scale, target = "infection")
          approx <- im$approximate_compartmental(method = method, N = N[n])

          # Append to existing results
          if (cachem::is.key_missing(current_approxes)) {
            current_approxes <- list()
          }
          current_approxes <- modifyList(current_approxes, stats::setNames(list(approx), N[n]))

          # Store to cache
          cache$set(key = glue::glue("{model_name}-{method}"), current_approxes)
        }

        # Check if approximation has converged
        if (identical(N_converged, numeric(0)) && length(current_approxes) > 1) {
          prev_values <- purrr::map_dbl(current_approxes, ~ purrr::pluck(., "value")) |>
            tibble::enframe(name = "N", value = "value") |>
            dplyr::mutate("N" = as.numeric(N)) |>
            dplyr::filter(.data$N <= N[n])

          # Look for the N that caused convergence using Kneedle algorithm
          N_converged <- tryCatch(
            kneedle::kneedle(
              x = prev_values$N,
              y = prev_values$value,
              decreasing = TRUE,
              concave = FALSE,
              sensitivity = 1
            ),
            error = function(e) numeric(0)
          ) |>
            purrr::pluck(1, .default = numeric(0))

          # In some cases, values are increasing not decreasing, so we manually detect these
          # (We allow a small increase to account for numerical imprecision)
          detect_increase <- \(x) ((x - cummin(x)) / cummin(x)) > 1e-3
          if (identical(N_converged, numeric(0)) && any(detect_increase(prev_values$value))) {
            N_converged <- prev_values$N[[which(detect_increase(prev_values$value))[1]]]
          }
        }
      }

      return(ifelse(identical(N_converged, numeric(0)), NA, N_converged))
    }
  ) |>
  tibble::tibble(
    "model" = purrr::map_chr(combinations_single$model, ~ purrr::pluck(., 2)),
    "method" = combinations_single$method,
    "N" = _)
```

```{r check monotonicity in solution}
non_monotonicity_single <- combinations_single |>
  purrr::pmap(
    .progress = interactive(),
    .f = \(model_zip, method) {

      # Unpack model
      model <- model_zip[[1]]
      model_name <- model_zip[[2]]
      time_scale <- model_zip[[3]]

      # Check if we have already computed this value
      current_approxes <- cache$get(key = glue::glue("{model_name}-{method}"))
      if (cachem::is.key_missing(current_approxes)) {
        return(NULL)
      } else {
        monotoncity <- current_approxes |>
          purrr::list_transpose() |>
          tibble::as_tibble() |>
          dplyr::transmute(
            "model" = !!model_name,
            .data$method,
            .data$N,
            .data$gamma,
            "monotone" = purrr::map_lgl(.data$gamma, ~ all(diff(.) <= 0))
          )
        return(monotoncity)
      }
    }
  ) |>
  purrr::list_rbind()

non_monotonicity_single |>
  dplyr::filter(!.data$monotone)
```



```{r detect single target convergence}
convergence_single <- combinations_single |>
  purrr::pmap_dbl(
    .progress = interactive(),
    .f = \(model_zip, method) {

      # Unpack model
      model <- model_zip[[1]]
      model_name <- model_zip[[2]]
      time_scale <- model_zip[[3]]

      # Place holder for the convergence value
      N_converged <- numeric(0)

      # Get the results
      current_approxes <- cache$get(key = glue::glue("{model_name}-{method}"))

      # Check if approximation has converged
      prev_values <- purrr::map_dbl(current_approxes, ~ purrr::pluck(., "value")) |>
        tibble::enframe(name = "N", value = "value") |>
        dplyr::mutate("N" = as.numeric(N))

      # Look for the N that caused convergence using Kneedle algorithm
      N_converged <- tryCatch(
        kneedle::kneedle(
          x = prev_values$N,
          y = prev_values$value,
          decreasing = TRUE,
          concave = FALSE,
          sensitivity = 1
        ),
        error = function(e) numeric(0)
      ) |>
        purrr::pluck(1, .default = numeric(0))

      # In some cases, values are increasing not decreasing, so we manually detect these
      # (We allow a small increase to account for numerical imprecision)
      detect_increase <- \(x) (x - cummin(x)) > 1e-3 * cummin(x)
      if (identical(N_converged, numeric(0)) && any(detect_increase(prev_values$value))) {
        N_converged <- prev_values$N[[which(detect_increase(prev_values$value))[1]]]
      }

      return(ifelse(identical(N_converged, numeric(0)), NA, N_converged))
    }
  ) |>
  tibble::tibble(
    "model" = purrr::map_chr(combinations_single$model, ~ purrr::pluck(., 2)),
    "method" = combinations_single$method,
    "N" = _)
```



```{r elbow curve single target}
metrics_single <- combinations_single |>
  purrr::pmap(
    .progress = interactive(),
    .f = \(model_zip, method) {

      # Unpack model
      model <- model_zip[[1]]
      model_name <- model_zip[[2]]
      time_scale <- model_zip[[3]]

      # Check if we have already computed this value
      current_approxes <- cache$get(key = glue::glue("{model_name}-{method}"))
      if (cachem::is.key_missing(current_approxes)) {
        metrics <-data.frame(
          "model" = model_name,
          "method" = method,
          "N" = NA,
          "value" = NA,
          "execution_time" = NA
        )
      } else {
        metrics <- current_approxes |>
          purrr::list_transpose() |>
          tibble::as_tibble() |>
          dplyr::transmute("model" = !!model_name, "method" = !!method, .data$N, .data$value, .data$execution_time)
      }

      return(metrics)
    }
  ) |>
  purrr::list_rbind()


# Prepare for plotting
metrics_single_gg <- metrics_single |>
  dplyr::mutate("execution_time" = as.numeric(.data$execution_time)) |>
  tidyr::separate_wider_delim("model", delim = "-", names = c("model", "variant"), too_few = "align_start") |>
  dplyr::mutate("variant" = dplyr::case_when(
    is.na(variant) ~ "base",
    variant == "c" ~ "non-zero asymptote",
    variant == "2t" ~ "twice the time scale"
  )) |>
  dplyr::filter(!is.na(value)) |>
  tidyr::pivot_longer(!c("model", "variant", "method", "N"), names_to = "metric")

convergence_single_gg <- convergence_single |>
   tidyr::separate_wider_delim("model", delim = "-", names = c("model", "variant"), too_few = "align_start") |>
  dplyr::mutate("variant" = dplyr::case_when(
    is.na(variant) ~ "base",
    variant == "c" ~ "non-zero asymptote",
    variant == "2t" ~ "twice the time scale"
  ))

# Plot
ggplot2::ggplot(metrics_single_gg, ggplot2::aes(x = N, y = value, color = method, linetype = variant)) +
  ggplot2::geom_line(linewidth = 1) +
  ggplot2::geom_point() +
  ggplot2::scale_y_log10() +
  ggplot2::facet_grid(metric ~ model, scales = "free") +
  ggplot2::labs(x = "N", y = "Metric") +
  ggplot2::theme_bw()
```


```{r}
metrics_single_gg |>
  dplyr::filter(.data$metric == "value") |>
  ggplot2::ggplot(ggplot2::aes(x = N, y = value, color = method)) +
  ggplot2::geom_line(linewidth = 1) +
  ggplot2::geom_point() +
  ggplot2::geom_vline(data = convergence_single_gg, ggplot2::aes(xintercept = N, linetype = method, color = method)) +
  #ggplot2::scale_y_log10() +
  ggplot2::facet_grid(model ~ variant, scales = "free") +
  ggplot2::labs(x = "N", y = "Value") +
  ggplot2::theme_bw()
```

```{r debug}
purrr::pluck(cache$get(key = glue::glue("sigmoidal-free_delta")), "3")
```

```{r debug}
metrics_single |>
  dplyr::filter(.data$model == "sigmoidal", .data$method == "free_delta")
```

```{r debug}
metrics_single_gg |>
  dplyr::filter(.data$model == "sigmoidal", .data$variant == "base", .data$method == "free_delta")
```




```{r run all double targets}
cache <- cachem::cache_disk(dir = devtools::package_file("vignettes/articles/article_data/double"))

# Set the combinations to test
combinations_double <- tidyr::expand_grid(
  model1 = zip(models, model_names, time_scales),
  model2 = zip(models, model_names, time_scales),
  method = c("free_gamma", "free_delta", "all_free")
)

#future::plan("sequential")
#future::plan("multisession")

# Run the approximations and note the convergence point
combinations_double |>
  #furrr::future_pwalk(
  purrr::pwalk(
    .progress = interactive(),
    #.options = furrr::furrr_options("seed" = TRUE),
    .f = \(model1_zip, model2_zip, method) {

      N = seq(from = 2, to = 5, by = 1)

      # Unpack model
      model1 <- model1_zip[[1]]
      model1_name <- model1_zip[[2]]
      time_scale1 <- model1_zip[[3]]

      model2 <- model2_zip[[1]]
      model2_name <- model2_zip[[2]]
      time_scale2 <- model2_zip[[3]]

      # Place holder for the convergence value
      N_converged <- numeric(0)

      # Generate approximations and store them and the convergence point
      for (n in seq_along(N)) {

        # Get the results up until now
        current_approxes <- cache$get(key = glue::glue("{model1_name}-{model2_name}-{method}"))

        # Compute next values

        # Set the target and approximate
        im$set_waning_model(model1, time_scale = time_scale1, target = "infection")
        im$set_waning_model(model2, time_scale = time_scale2, target = "hospitalisation")
        approx <- im$approximate_compartmental(method = method, N = N[n])

        # Append to existing results
        if (cachem::is.key_missing(current_approxes)) {
          current_approxes <- list()
        }
        current_approxes <- modifyList(current_approxes, stats::setNames(list(approx), N[n]))

        # Store to cache
        cache$set(key = glue::glue("{model1_name}-{model2_name}-{method}"), current_approxes)
      }
    }
  )
```


```{r detect double target convergence}
convergence_double <- combinations_double |>
  purrr::pmap(
    .progress = interactive(),
    .f = \(model1_zip, model2_zip, method) {

      # Unpack model
      model1 <- model1_zip[[1]]
      model1_name <- model1_zip[[2]]
      time_scale1 <- model1_zip[[3]]

      model2 <- model2_zip[[1]]
      model2_name <- model2_zip[[2]]
      time_scale2 <- model2_zip[[3]]

      # Get the results
      current_approxes <- cache$get(key = glue::glue("{model1_name}-{model2_name}-{method}"))


      # Check if approximation has converged
      prev_values <- purrr::map_dbl(current_approxes, ~ purrr::pluck(., "value")) |>
        tibble::enframe(name = "N", value = "value") |>
        dplyr::mutate("N" = as.numeric(N))

      # Look for the N that caused convergence using kneedle algorithm
      N_converged <- tryCatch(
        kneedle::kneedle(
          x = prev_values$N,
          y = prev_values$value,
          decreasing = TRUE,
          concave = FALSE,
          sensitivity = 1
        ),
        error = function(e) numeric(0)
      ) |>
        purrr::pluck(1, .default = numeric(0))

      # In some cases, values are increasing not decreasing, so we manually detect these
      # (We allow a small increase to account for numerical imprecision)
      detect_increase <- \(x) (x - cummin(x)) > 1e-3 *  cummin(x)
      if (identical(N_converged, numeric(0)) && any(detect_increase(prev_values$value))) {
        N_converged <- prev_values$N[[which(detect_increase(prev_values$value))[1]]]
      }

      return(ifelse(identical(N_converged, numeric(0)), NA, N_converged))
    }
  ) |>
  tibble::tibble(
    "model_1" = purrr::map_chr(combinations_double$model1, ~ purrr::pluck(., 2)),
    "model_2" = purrr::map_chr(combinations_double$model2, ~ purrr::pluck(., 2)),
    "method" = combinations_double$method,
    "N" = _)
```


```{r elbow curve double target}
metrics_double <- combinations_double |>
  purrr::pmap(
    .progress = interactive(),
    .f = \(model1_zip, model2_zip, method) {

      # Unpack model
      model1 <- model1_zip[[1]]
      model1_name <- model1_zip[[2]]
      time_scale1 <- model1_zip[[3]]

      model2 <- model2_zip[[1]]
      model2_name <- model2_zip[[2]]
      time_scale2 <- model2_zip[[3]]

      # Check if we have already computed this value
      current_approxes <- cache$get(key = glue::glue("{model1_name}-{model2_name}-{method}"))
      if (cachem::is.key_missing(approx)) {
        metrics <-data.frame(
          "model" = !!paste(model1_name, model2_name, sep = "/"),
          "method" = method,
          "N" = NA,
          "value" = NA,
          "execution_time" = NA
        )
      } else {
        metrics <- current_approxes |>
          purrr::list_transpose() |>
          tibble::as_tibble() |>
          dplyr::transmute(
            "model" = !!paste(model1_name, model2_name, sep = "/"),
            "method" = !!method,
            .data$N,
            .data$value,
            .data$execution_time
          )
      }

      return(metrics)
    }
  ) |>
  purrr::list_rbind()


# Prepare for plotting
metrics_double_gg <- metrics_double |>
  dplyr::inner_join(
    "model" = c(
      "exp_sum/exp_sum",
      "sigmoidal/sigmoidal",
      "exp_sum/sigmoidal",
      "exp_sum/exp_sum-2t",
      "sigmoidal/sigmoidal-2t",
      "exp_sum/exp_sum-c",
      "sigmoidal/sigmoidal-c",
      "exp_sum/sigmoidal-2t",
      "exp_sum/sigmoidal-c",
    ),
    by = "model"
  )
  dplyr::mutate("execution_time" = as.numeric(.data$execution_time)) |>
  dplyr::filter(!is.na(value)) |>
  tidyr::pivot_longer(!c("model", "method", "N"), names_to = "metric")

convergence_double_gg <- convergence_double |>
  tidyr::unite("model", c("model_1", "model_2"), sep = "/")


# Plot
ggplot2::ggplot(metrics_double_gg, ggplot2::aes(x = N, y = value, color = method)) +
  ggplot2::geom_line(linewidth = 1) +
  ggplot2::geom_point() +
  #ggplot2::scale_y_log10() +
  ggplot2::facet_grid(metric ~ model, scales = "free") +
  ggplot2::labs(x = "N", y = "Metric") +
  ggplot2::theme_bw()
```
