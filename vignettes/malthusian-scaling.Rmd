---
title: "Notes: Accounting for structual differences in malthusian growth rates"

author: "Rasmus Skytte RandlÃ¸v"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Notes: Accounting for structual differences in malthusian growth rates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

devtools::load_all()
```

# Introduction
Let us begin by considering a general SEIR model with $K$ and $L$ consecutive $E$ and $I$ states respectively, which are governed by the rates $r_e$ and $r_i$ respectively.
Let us further assume that we have some signal for infections $I^*(t)$ which we would like our model to match.

For now, we operate with two possibilities:
1) The signal is related to testing activity
2) The signal is related to prevalence

The general approach is to consider the derivatives of the signal and link these to the E and I states of the model.

Dependent on the type of signal, there is some variation on how this link is established.


# Without scaling

We begin by generating some synthetic data from different underlying data-generating processes
```{r}
# Set the time scales of the problem
rE = 1 / 2
rI = 1 / 4

combinations <- data.frame(K = c(1, 1, 2, 2, 2, 3), L = c(1, 2, 1, 2, 3, 3))

# Run a SIR model to generate the target of our initialisation
m <- DiseasyModelOdeSeir$new(
  season = T, activity = T, variant = T,
  observables = DiseasyObservables$new(
    conn = DBI::dbConnect(RSQLite::SQLite()),
    last_queryable_date = Sys.Date() - 1
  ),
  parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0.6),
  malthusian_scaling = FALSE
)
    
# Get a reference to the private environment
private <- m$.__enclos_env__$private

# Create a "fixed" scaling of the growth rates
reference_growth_rate <- private$compute_malthusian_growth_rate(K = 0, L = 1, age_cuts_lower = 0)
seir_growth_rate <- private$compute_malthusian_growth_rate(K = 1, L = 1, age_cuts_lower = 0)
beta <- private$.parameters$overall_infection_risk * (reference_growth_rate / seir_growth_rate)  

synthetic_model <- combinations |>
  purrr::pmap(\(K, L) {
    
    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = L, "R" = 1),
      disease_progression_rates = c("E" = rE, "I" = rI),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = beta),
      malthusian_scaling = FALSE
    )
    
    # Get a reference to the private environment
    private <- m$.__enclos_env__$private

    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(0.001, rep(0, K - 1), rep(0, L), 0, 0.999)
    
    # Run solver across scenario change to check for long-term leakage
    deSolve::ode(y = y0, times = seq(0, 60), func = private %.% rhs, parms = NULL)
  })

names(synthetic_model) <- purrr::pmap_chr(combinations, \(K, L) glue::glue("L = {L}, K = {K}"))

tmax <- 24 #34 #40
offset <- 7
t0 <- tmax - offset

incidence_signal_no_scaling <- purrr::imap(synthetic_model, ~ {
  n_states <-as.numeric(stringr::str_extract_all(.y, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]
  
  # Retrieve the signal
  I <- L * rI * head(.x[, K + 2], tmax)
  
  # Adding some noise
  pop = 1e3
  II <- I# purrr::map_dbl(I, \(lambda) rpois(1, pop * lambda)) / pop  
  
  data.frame(t = head(.x[, 1], tmax), incidence = II)
})

incidence_signal_no_scaling_gg <- purrr::imap(incidence_signal_no_scaling, ~ dplyr::mutate(.x, true_configuration = .y)) |>
  purrr::list_rbind()

ggplot2::ggplot(incidence_signal_no_scaling_gg, ggplot2::aes(x = t, y = incidence, color = true_configuration)) +
  ggplot2::geom_line(linewidth = 1) + 
  ggplot2::scale_y_continuous(transform = "log") +
  ggplot2::theme_bw()
```


```{r}
synthetic_model <- combinations |>
  purrr::pmap(\(K, L) {
    
    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = L, "R" = 1),
      disease_progression_rates = c("E" = rE, "I" = rI),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0.6)
    )
    
    # Get a reference to the private environment
    private <- m$.__enclos_env__$private
    
    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(0.001, rep(0, K - 1), rep(0, L), 0, 0.999)
    
    # Run solver across scenario change to check for long-term leakage
    deSolve::ode(y = y0, times = seq(0, 60), func = private %.% rhs, parms = NULL)
  })

names(synthetic_model) <- purrr::pmap_chr(combinations, \(K, L) glue::glue("L = {L}, K = {K}"))

tmax <- 24 #34 #40
offset <- 7
t0 <- tmax - offset

incidence_signal_no_scaling <- purrr::imap(synthetic_model, ~ {
  n_states <-as.numeric(stringr::str_extract_all(.y, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]
  
  # Retrieve the signal
  I <- L * rI * head(.x[, K + 2], tmax)
  
  # Adding some noise
  pop = 1e3
  II <- I# purrr::map_dbl(I, \(lambda) rpois(1, pop * lambda)) / pop  
  
  data.frame(t = head(.x[, 1], tmax), incidence = II)
})

incidence_signal_no_scaling_gg <- purrr::imap(incidence_signal_no_scaling, ~ dplyr::mutate(.x, true_configuration = .y)) |>
  purrr::list_rbind()

ggplot2::ggplot(incidence_signal_no_scaling_gg, ggplot2::aes(x = t, y = incidence, color = true_configuration)) +
  ggplot2::geom_line(linewidth = 1) + 
  ggplot2::scale_y_continuous(transform = "log") +
  ggplot2::theme_bw()
```
