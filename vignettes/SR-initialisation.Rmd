---
title: "Notes: Initialising a SEIR model from incidence data"

author: "Rasmus Skytte RandlÃ¸v"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Notes: Initialising a SEIR model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

devtools::load_all()
```

# Introduction
Let us begin by considering a general SEIR model with $K$, $L$ and $M$ consecutive $E$, $I$, and $R$ states respectively, which are governed by the rates $r_e$ and $r_i$ respectively.
Let us further assume that we have some signal for infections $I^*(t)$ which we would like our model to match.

For now, we operate with two possibilities:
1) The signal is related to testing activity
2) The signal is related to prevalence

The general approach is to consider the derivatives of the signal and link these to the E and I states of the model.

Dependent on the type of signal, there is some variation on how this link is established.


## Incidence signal
If the signal, $I^*$, is test data, we can assume that tests occurs when exiting $I_1$ in the model.

That is, we assume $I^* = r_i I_1$.

We can modify the SEIR equation to take this signal as a forcing function with no $E$ states and one less $I$ state (no $I_1$ state).
The equations are as normal expect for the following changes:
$$
I = \frac{I^*}{r_i} + \sum_{l=2}^L I_l
$$

$$
\frac{dI_2}{dt} = I^* - r_i I_2
$$
If we start this system at a time where there are no new infections, we can initialize $I_l = 0$, and run the simulation forward to estimate the $S$ and $R$ populations at the point of interest.

There is an interesting consequence here. If the equations are modified as above, we can also infer what the corresponding value of $\beta$ should be. Since we claim to know $I$ and $S$, we can solve for what $\beta$ should be.

## Prevalence signal

If we instead have a measure of the true number of infected, $I^* = \sum_l I_l$, then we only need to force the infection pressure:

$$
I = I^*
$$
Here we would also need to start the system at a time where there are no new infections ($I_l = 0$).

# Testing the methods

We begin by generating some synthetic data from different underlying data-generating processes
```{r synthetic_data, include = FALSE}
# Set the time scales of the problem
rE = 1 / 2
rI = 1 / 4

combinations <- data.frame(K = c(1, 1, 2, 2, 3), L = c(1, 2, 1, 2, 3))

synthetic_model <- combinations |>
  purrr::pmap(\(K, L) {

    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = L, "R" = 1),
      disease_progression_rates = c("E" = rE, "I" = rI),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0.9)
    )

    # Get a reference to the private environment
    private <- m$.__enclos_env__$private

    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(0.001, rep(0, K - 1), rep(0, L), 0, 0.999)

    # Run solver across scenario change to check for long-term leakage
    deSolve::ode(y = y0, times = seq(0, 60), func = private %.% rhs, parms = NULL)
  })

names(synthetic_model) <- purrr::pmap_chr(combinations, \(K, L) glue::glue("K = {K}, L = {L}"))

```

We define a function to run the model forward based on the estimated initial state vector.
```{r}
run_model <- function(EI_states, R, S, K, L, rE, rI, offset = 0, signal = "incidence", scale_EI = TRUE) {
  checkmate::assert_numeric(EI_states, lower = 0)
  checkmate::assert_choice(signal, c("incidence", "prevalence"))

  # Run a SIR model to generate the target of our initialisation
  m <- DiseasyModelOdeSeir$new(
    season = T, activity = T,
    observables = DiseasyObservables$new(
      conn = DBI::dbConnect(RSQLite::SQLite()),
      last_queryable_date = Sys.Date() - 1
    ),
    variant = DiseasyVariant$new(n_variants = 1),
    compartment_structure = c("E" = K, "I" = L, "R" = 1),
    disease_progression_rates = c("E" = rE, "I" = rI),
    parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0.9)
  )

  # Get a reference to the private environment
  private <- m$.__enclos_env__$private


  times <- seq(0, 10, length.out = 100) + offset

  if (scale_EI) {
    y0 <- c(EI_states / sum(EI_states) * (1 - R - S), R, S)
  } else {
    y0 <- c(EI_states, R / S * (1 - sum(EI_states)), (1 - R / S) * (1 - sum(EI_states)))
  }

  sol <- deSolve::ode(
    y = y0,
    times = times,
    func = private %.% rhs,
    parms = NULL,
    abstol = 1e-12, reltol = 1e-12
  )


  if (signal == "incidence") {
    return(data.frame(t = t0 + times, incidence = L * rI * sol[, K + 2]))
  } else if (signal == "prevalence") {
    return(data.frame(t = t0 + times, prevalence = rowSums(sol[, (K + 2):(K + L + 1), drop = FALSE])))
  }

}
```

## Incidence signal
With the true solutions generated, we now generate some observational signal with noise from the $I_1$ state.
```{r}
tmax <- 24
offset <- 7
t0 <- tmax - offset

incidence_signal <- purrr::imap(synthetic_model, ~ {
  n_states <-as.numeric(stringr::str_extract_all(.y, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]

  # Retrieve the signal
  I <- L * rI * head(.x[, K + 2], tmax)

  # Adding some noise
  pop = 1e3
  II <- purrr::map_dbl(I, \(lambda) rpois(1, pop * lambda)) / pop

  data.frame(t = head(.x[, 1], tmax), incidence = II)
})

incidence_signal_gg <- purrr::imap(incidence_signal, ~ dplyr::mutate(.x, true_configuration = .y)) |>
  purrr::list_rbind()

ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()

```


And then we can run this model using the true state from the model to check that it works as expected
```{r}
exact_model_fit_gg <- purrr::imap(synthetic_model, ~ {
  n_states <-as.numeric(stringr::str_extract_all(.y, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]

  t <- .x[, 1]
  E <- .x[t == t0, 2:(K + 1)]
  I <- .x[t == t0, (K + 2):(K + L + 1)]
  R <- .x[t == t0, 1 + K + L+ 1]
  S <- .x[t == t0, 1 + K + L + 2]

  run_model(c(E, I), R, S, K, L, rE, rI, signal = "incidence") |>
    dplyr::mutate(true_configuration = .y, model_configuration = .y)
}) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_model_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

We see that the fitting works given perfect information.

Now lets estimate the state vector from the (noisy) synthetic signal.



### Initialising via solving the ODE of simplified system

```{r}
simplified_incidence_fit_gg <- purrr::map(names(incidence_signal), ~ {
  n_states <- as.numeric(stringr::str_extract_all(.x, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]

  ri <- rI * L
  re <- rE * K

    
  # Create the starting state vector and the constraints
  y0 <- c(rep(0, L - 1), 0, 1)
  y0 <- y0 / sum(y0)
  
  times <- seq(from = 0, to = t0)
  
    
  objective_function <- function(beta) {
    
  
    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = 0, "I" = L - 1, "R" = 1),
      disease_progression_rates = c("I" = rI * L / (L- 1)),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = beta)
    )
  
    # Get a interpolation of the signal
    signal <- approxfun(incidence_signal[[.x]]$t, incidence_signal[[.x]]$incidence, method = "constant")
    
    m$set_forcing_functions(
      infected_forcing = \(t, infected) signal(t) / ri + infected, # If L = 1, infected is numeric(0)
      i1_forcing = \(t, di1_dt) di1_dt + signal(t)
    )


    # Get a reference to the private environment
    private <- m$.__enclos_env__$private
    
    sol <- deSolve::ode(
      y = y0, 
      times = times, 
      func = private %.% rhs, 
      parms = NULL
    ) 
    
    return((sum(sol[nrow(sol), -1]) - 1)^2)
    
  }
  
  
  op <- optim(
    par = 0.5,
    fn = objective_function,
    method = "L-BFGS-B",
    lower = 0#, 
    #control = list(factr = 1e-2 / .Machine$double.eps)
  ) 
  
  sol <- deSolve::ode(
    y = y0,
    times = times,
    func = private %.% rhs,
    parms = NULL
  )
  
  plot()
  
  
  t <- synthetic_model[[.x]][, 1]
  R <- synthetic_model[[.x]][t == t0, 1 + K + L + 1]
  S <- synthetic_model[[.x]][t == t0, 1 + K + L + 2]

  run_model(EI_states, R, S, K, L, rE, rI, offset = 0, signal = "incidence", scale_EI = TRUE) |>
    dplyr::mutate(true_configuration = .x, model_configuration = .x)
}) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_model_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_incidence_fit_gg, color = "red", linewidth = 1) +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

#### Scaling EI states
```{r}
simplified_incidence_fit_gg <- expand.grid(
  model_configuration = names(incidence_signal_derivatives),
  true_configuration  = names(incidence_signal_derivatives)
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....

    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]


    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    ri <- rI * L
    re <- rE * K

    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(rep(1, K + 1), 0, 0)
    y0 <- y0 / sum(y0)

    times <- seq(- 1 / rE, 0, length.out = 10)
    ss <- predict(incidence_polyfits[[true_configuration]], data.frame(t = times))


    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = 1, "R" = 1),
      disease_progression_rates = c("E" = re / K, "I" = ri),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0)
    )

    # Get a reference to the private environment
    private <- m$.__enclos_env__$private


    objective_function <- function(y) {
      sol <- deSolve::ode(
        y = y,
        times = times,
        func = private %.% rhs,
        parms = NULL
      )

      I1 <- sol[, K + 2]

      sum(ri * I1 - ss)^2
    }

    op <- optim(
      par = y0,
      fn = objective_function,
      method = "L-BFGS-B",
      lower = 0,
      control = list(factr = 1e-2 / .Machine$double.eps)
    )

    EI_states <- op$par[1:(K + 1)]

    if (L > 1) {
      I_l <- predict(incidence_polyfits[[true_configuration]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()
      EI_states <- c(EI_states, I_l)
    }

    run_model(EI_states, R, S, K, L, rE, rI, signal = "incidence", scale_EI = TRUE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }, .progress = TRUE) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_model_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_incidence_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

#### Scaling RS states
```{r}
simplified_incidence_fit_gg <- expand.grid(
  model_configuration = names(incidence_signal_derivatives),
  true_configuration  = names(incidence_signal_derivatives)
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....

    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]


    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    ri <- rI * L
    re <- rE * K

    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(rep(1, K + 1), 0, 0)
    y0 <- y0 / sum(y0)

    times <- seq(- 1 / rE, 0, length.out = 10)
    ss <- predict(incidence_polyfits[[true_configuration]], data.frame(t = times))


    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = 1, "R" = 1),
      disease_progression_rates = c("E" = re / K, "I" = ri),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0)
    )

    # Get a reference to the private environment
    private <- m$.__enclos_env__$private


    objective_function <- function(y) {
      sol <- deSolve::ode(
        y = y,
        times = times,
        func = private %.% rhs,
        parms = NULL
      )

      I1 <- sol[, K + 2]

      sum(ri * I1 - ss)^2
    }

    op <- optim(
      par = y0,
      fn = objective_function,
      method = "L-BFGS-B",
      lower = 0,
      control = list(factr = 1e-2 / .Machine$double.eps)
    )

    EI_states <- op$par[1:(K + 1)]

    if (L > 1) {
      I_l <- predict(incidence_polyfits[[true_configuration]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()
      EI_states <- c(EI_states, I_l)
    }

    run_model(EI_states, R, S, K, L, rE, rI, signal = "incidence", scale_EI = FALSE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }, .progress = TRUE) |>
  purrr::list_rbind()


ggplot2::ggplot(incidence_signal_gg, ggplot2::aes(x = t, y = incidence)) +
  ggplot2::geom_line(data = exact_model_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_incidence_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```





## Prevalence signal

And now for the prevalence

```{r}
prevalence_signal <- purrr::imap(synthetic_model, ~ {
  n_states <-as.numeric(stringr::str_extract_all(.y, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]

  # Retrieve the signal
  I <- rowSums(head(.x[, (1 + K + 1):(1 + K + L), drop = FALSE], tmax))

  # Adding some noise
  pop = 1e3
  II <- purrr::map_dbl(I, \(lambda) rpois(1, pop * lambda)) / pop

  data.frame(t = head(.x[, 1], tmax), prevalence = II)
})

prevalence_signal_gg <- purrr::imap(prevalence_signal, ~ dplyr::mutate(.x, true_configuration = .y)) |>
  purrr::list_rbind()

ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()

```

```{r}
exact_model_fit_gg <- purrr::imap(synthetic_model, ~ {
  n_states <-as.numeric(stringr::str_extract_all(.y, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]

  t <- .x[, 1]
  E <- .x[t == t0, 2:(K + 1)]
  I <- .x[t == t0, (K + 2):(K + L + 1)]
  R <- .x[t == t0, 1 + K + L+ 1]
  S <- .x[t == t0, 1 + K + L + 2]

  run_model(c(E, I), R, S, K, L, rE, rI, signal = "prevalence") |>
    dplyr::mutate(true_configuration = .y, model_configuration = .y)
}) |>
  purrr::list_rbind()


ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_line(data = exact_model_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```


This method relies on fitting a polynomial to the latest period, so we do that here.
```{r}
poly_order <- 3

prevalence_polyfits <- purrr::map(prevalence_signal, ~ {
  lm(prevalence ~ poly(t, poly_order, raw = TRUE), data = dplyr::filter(dplyr::mutate(.x, t = t - t0), t <= 0))
})

prevalence_polyfit_projections <- prevalence_polyfits |>
  purrr::map(~ data.frame(t = prevalence_signal[[1]]$t, prevalence = predict(.x, data.frame(t = prevalence_signal[[1]]$t - t0))))

prevalence_polyfit_projections_gg <- purrr::imap(prevalence_polyfit_projections, ~ dplyr::mutate(.x, true_configuration = .y)) |>
  purrr::list_rbind()


ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_line(data = prevalence_polyfit_projections_gg, color = "red", linewidth = 1) +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "red") +
  ggplot2::geom_hline(
    ggplot2::aes(yintercept = c0),
    linetype = 2, color = "red",
    data = data.frame(c0 = purrr::map_dbl(prevalence_polyfits, ~ purrr::pluck(.x, "coefficients", 1)),
                      true_configuration = names(prevalence_polyfits))
  ) +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

The method relies on a vector of derivatives of the signal, which we compute here:

```{r}
# Compute the derivatives of the signal ("signal" vector)
max_order_derivative <- 2

prevalence_signal_derivatives <- purrr::map(
  incidence_polyfits, ~ stats::setNames(
    .x$coefficients[1:(max_order_derivative + 1)] * pmax(1, seq(max_order_derivative + 1) - 1),
    c("I^*", "dI^*/dt", "d^2I^*/dt^2")
  )
)

prevalence_signal_derivatives
```
### Direct inference from prevalence signal
```{r}
# prevalence_model_fit_gg <- purrr::map(names(prevalence_signal_derivatives), ~ {
#   n_states <- as.numeric(stringr::str_extract_all(.x, r"{\d}")[[1]])
#   K <<- n_states[1]
#   L <<- n_states[2]
#
#   ri <<- rI * L
#   re <<- rE * K
#
#   # Compute the matrix
#   M <- matrix(rep(0, (K + L) * K), ncol = K + L)
#   active_row <- c(rep(0, K - 1), re, rep(0, L - 1), -ri)
#   progression_rates <- c(rep(re, K), rep(ri, L))
#
#   for (k in seq(K)) {
#     if (k > 1) {
#       stopifnot(active_row[[1]] == 0) # We cannot iterate too deeply
#
#       # Implement branching process which picks up the progression rate factors as it branches down.
#       active_row <- active_row |>
#         purrr::imap(
#           \(r, idx) {
#             c(
#               rep(0, max(0, idx - 2)), # left pad with zeros
#               progression_rates[idx - 1] * r,
#               - progression_rates[idx] * r,
#               rep(0, K + L - idx) # right pad with zeros
#             )
#           }
#         ) |>
#         purrr::reduce(`+`)
#     }
#
#     M[k, ] <- active_row
#   }
#
#   # Define the vector for the matrix multiplication
#   ss <- prevalence_signal_derivatives[[.x]][2:(K + 1)]
#   ss[is.na(ss)] <- 0
#
#   checkmate::assert_number(nrow(M), lower = ncol(M) - 2, upper = ncol(M))
#
#   # Add additional constraints
#   # I* = sum_l I_l
#   if (nrow(M) < ncol(M)) {
#     M <- rbind(
#       M,
#       c(rep(0, K), rep(1, L))
#     )
#     ss <- c(ss, prevalence_signal_derivatives[[.x]][1])
#   }
#
#   # Add additional constraints
#   # I*(1/re) = sum_l^(L-1) I_l + ri/re I_l + E_k
#   if (nrow(M) < ncol(M)) {
#     time_ratio <- re / ri
#     l <- min(floor(time_ratio), L)
#     contribution <- c(rep(1, L - l), rep(0, l))
#     contribution[max(L - l, 1)] <- 1 - (1 + time_ratio) %% 1
#
#     M <- rbind(
#       M,
#       c(rep(0, K - 1), 1, contribution)
#     )
#     ss <- c(ss, predict(prevalence_polyfits[[.x]], data.frame(t = - max(K, L) / ri * 0.5)))
#   }
#
#   M <<- M
#   ss <<- ss
#   EI_states <- solve(M, ss)
#
#   print(EI_states)
#
#   t <- synthetic_model[[.x]][, 1]
#   R <- synthetic_model[[.x]][t == t0, 1 + K + L + 1]
#   S <- synthetic_model[[.x]][t == t0, 1 + K + L + 2]
#
#   run_model(EI_states, R, S, K, L, rE, rI, signal = "prevalence", scale_EI = TRUE) |>
#     dplyr::mutate(true_configuration = .x, model_configuration = .x)
# }) |>
#   purrr::list_rbind()
#
#
# ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
#   ggplot2::geom_line(data = exact_model_fit_gg, color = "darkgrey", linewidth = 2) +
#   ggplot2::geom_line(data = prevalence_model_fit_gg, color = "red", linewidth = 1) +
#   ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
#   ggplot2::geom_point() +
#   ggplot2::facet_wrap(~ true_configuration) +
#   ggplot2::theme_bw()
```




### Initialising via solving the ODE of simplified system
```{r}
simplified_model_fit_gg <- purrr::map(names(prevalence_signal_derivatives), ~ {
  n_states <- as.numeric(stringr::str_extract_all(.x, r"{\d}")[[1]])
  K <- n_states[1]
  L <- n_states[2]

  ri <- rI * L
  re <- rE * K

  # Generate a uniform initial state_vector that sums to 1
  y0 <- c(rep(1, K + L), 0, 0)
  y0 <- y0 / sum(y0)

  times <- seq(- 1 / rE, 0, length.out = 10)
  ss <- predict(prevalence_polyfits[[.x]], data.frame(t = times))


  # Run a SIR model to generate the target of our initialisation
  m <- DiseasyModelOdeSeir$new(
    season = T, activity = T,
    observables = DiseasyObservables$new(
      conn = DBI::dbConnect(RSQLite::SQLite()),
      last_queryable_date = Sys.Date() - 1
    ),
    variant = DiseasyVariant$new(n_variants = 1),
    compartment_structure = c("E" = K, "I" = L, "R" = 1),
    disease_progression_rates = c("E" = re / K, "I" = ri),
    parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0)
  )

  # Get a reference to the private environment
  private <- m$.__enclos_env__$private

  objective_function <- function(y) {
    sol <- deSolve::ode(
      y = y,
      times = times,
      func = private %.% rhs,
      parms = NULL
    )

    I <- rowSums(sol[, (1 + K + 1):(1 + K + L), drop = FALSE])

    sum(I - ss)^2
  }

  op <- optim(
    par = y0,
    fn = objective_function,
    method = "L-BFGS-B",
    lower = 0
  )

  EI_states <- op$par[1:(K + 1)]

  if (L > 1) {
    I_l <- predict(prevalence_polyfits[[.x]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()
    EI_states <- c(EI_states, I_l)
  }

  t <- synthetic_model[[.x]][, 1]
  R <- synthetic_model[[.x]][t == t0, 1 + K + L + 1]
  S <- synthetic_model[[.x]][t == t0, 1 + K + L + 2]

  run_model(EI_states, R, S, K, L, rE, rI, signal = "prevalence", scale_EI = TRUE) |>
    dplyr::mutate(true_configuration = .x, model_configuration = .x)
}) |>
  purrr::list_rbind()


ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_line(data = exact_model_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_model_fit_gg, color = "red", linewidth = 1) +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

#### Scaling EI states
```{r}
simplified_prevalence_fit_gg <- expand.grid(
  model_configuration = names(prevalence_signal_derivatives),
  true_configuration  = names(prevalence_signal_derivatives)
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....

    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]


    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    ri <- rI * L
    re <- rE * K

    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(rep(1, K + 1), 0, 0)
    y0 <- y0 / sum(y0)

    times <- seq(- 1 / rE, 0, length.out = 10)
    ss <- predict(prevalence_polyfits[[true_configuration]], data.frame(t = times))


    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = 1, "R" = 1),
      disease_progression_rates = c("E" = re / K, "I" = ri),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0)
    )

    # Get a reference to the private environment
    private <- m$.__enclos_env__$private


    objective_function <- function(y) {
      sol <- deSolve::ode(
        y = y,
        times = times,
        func = private %.% rhs,
        parms = NULL
      )

      I1 <- sol[, K + 2]

      sum(ri * I1 - ss)^2
    }

    op <- optim(
      par = y0,
      fn = objective_function,
      method = "L-BFGS-B",
      lower = 0,
      control = list(factr = 1e-2 / .Machine$double.eps)
    )

    EI_states <- op$par[1:(K + 1)]

    if (L > 1) {
      I_l <- predict(prevalence_polyfits[[true_configuration]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()
      EI_states <- c(EI_states, I_l)
    }

    run_model(EI_states, R, S, K, L, rE, rI, signal = "prevalence", scale_EI = TRUE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }, .progress = TRUE) |>
  purrr::list_rbind()


ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_line(data = exact_model_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_prevalence_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```


#### Scaling RS states
```{r}
simplified_prevalence_fit_gg <- expand.grid(
  model_configuration = names(prevalence_signal_derivatives),
  true_configuration  = names(prevalence_signal_derivatives)
) |>
  purrr::pmap(\(true_configuration, model_configuration) {
    true_configuration  <- as.character(true_configuration)  # R forces us to do needless conversion of variables
    model_configuration <- as.character(model_configuration) # since it refuses to respect data.types....

    # First retrieve the S and R states from the true data
    n_states <- as.numeric(stringr::str_extract_all(true_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    t <- synthetic_model[[true_configuration]][, 1]
    R <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 1]
    S <- synthetic_model[[true_configuration]][t == t0, 1 + K + L + 2]


    # The estimate E and I from the signal data
    n_states <- as.numeric(stringr::str_extract_all(model_configuration, r"{\d}")[[1]])
    K <- n_states[1]
    L <- n_states[2]

    ri <- rI * L
    re <- rE * K

    # Generate a uniform initial state_vector that sums to 1
    y0 <- c(rep(1, K + 1), 0, 0)
    y0 <- y0 / sum(y0)

    times <- seq(- 1 / rE, 0, length.out = 10)
    ss <- predict(prevalence_polyfits[[true_configuration]], data.frame(t = times))


    # Run a SIR model to generate the target of our initialisation
    m <- DiseasyModelOdeSeir$new(
      season = T, activity = T,
      observables = DiseasyObservables$new(
        conn = DBI::dbConnect(RSQLite::SQLite()),
        last_queryable_date = Sys.Date() - 1
      ),
      variant = DiseasyVariant$new(n_variants = 1),
      compartment_structure = c("E" = K, "I" = 1, "R" = 1),
      disease_progression_rates = c("E" = re / K, "I" = ri),
      parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0)
    )

    # Get a reference to the private environment
    private <- m$.__enclos_env__$private


    objective_function <- function(y) {
      sol <- deSolve::ode(
        y = y,
        times = times,
        func = private %.% rhs,
        parms = NULL
      )

      I1 <- sol[, K + 2]

      sum(ri * I1 - ss)^2
    }

    op <- optim(
      par = y0,
      fn = objective_function,
      method = "L-BFGS-B",
      lower = 0,
      control = list(factr = 1e-2 / .Machine$double.eps)
    )

    EI_states <- op$par[1:(K + 1)]

    if (L > 1) {
      I_l <- predict(prevalence_polyfits[[true_configuration]], data.frame(t = -(seq(2, L) - 1) / ri - K / re)) |> as.numeric()
      EI_states <- c(EI_states, I_l)
    }

    run_model(EI_states, R, S, K, L, rE, rI, signal = "prevalence", scale_EI = FALSE) |>
      dplyr::mutate(true_configuration = true_configuration, model_configuration = model_configuration)
  }, .progress = TRUE) |>
  purrr::list_rbind()


ggplot2::ggplot(prevalence_signal_gg, ggplot2::aes(x = t, y = prevalence)) +
  ggplot2::geom_line(data = exact_model_fit_gg, color = "darkgrey", linewidth = 2) +
  ggplot2::geom_line(data = simplified_prevalence_fit_gg, ggplot2::aes(color = model_configuration), linewidth = 1) +
  ggplot2::scale_color_brewer(palette = "Dark2") +
  ggplot2::geom_vline(xintercept = t0, linetype = 2, color = "black") +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(~ true_configuration) +
  ggplot2::theme_bw()
```

























```{r}
K <- 2 # Number of E states
L <- 2
ri <- 1
re <- 0.9

# Run a SIR model to generate the target of our initialisation
m <- DiseasyModelOdeSeir$new(
  season = T, activity = T,
  observables = DiseasyObservables$new(
    conn = DBI::dbConnect(RSQLite::SQLite()),
    last_queryable_date = Sys.Date() - 1
  ),
  variant = DiseasyVariant$new(n_variants = 1),
  compartment_structure = c("E" = K, "I" = 1, "R" = 1),
  disease_progression_rates = c("E" = re / K, "I" = ri),
  parameters = list("age_cuts_lower" = 0, "overall_infection_risk" = 0)
)

# Get a reference to the private environment
private <- m$.__enclos_env__$private


```
























<!-- ## Implementation of true-infected signal with different infectivity -->
<!-- ```{r} -->
<!-- K <- 2 # Number of E states -->
<!-- L <- 2 # Number of I states -->
<!-- ri <- rI * L -->
<!-- re <- rE * K -->
<!-- w <- 1 - 0.25*seq(L)/L -->
<!-- w <- L * w / sum(w) -->
<!-- #w <- c(1, 2) -->

<!-- # Compute the derivatives of the signal ("signal" vector) -->
<!-- signal <- polyfit(-max(K, L) / ri * 0.5)$coefficients |> -->
<!--   (\(coefficients) coefficients* pmax(1, seq_along(coefficients) - 1))() -->
<!-- names(signal) <- c("I^*", "dI^*/dt", "d^2I^*/dt^2") -->

<!-- # Compute the matrix -->
<!-- M <- matrix(rep(0, (K + L) * K), ncol = K + L) -->
<!-- progression_rates <- c(rep(re, K), rep(ri, L)) -->
<!-- active_row <- c(rep(0, K-1), progression_rates[K:(K+L)] * c(w, 0)) - c(rep(0, K-1), progression_rates[K:(K+L)] * c(0, w)) -->


<!-- for (k in seq(K)) { -->
<!--   if (k > 1) { -->
<!--     stopifnot(active_row[[1]] == 0) # We cannot iterate too deeply -->

<!--     # Implement branching process which picks up the progression rate factors as it branches down. -->
<!--     active_row <- active_row |> -->
<!--       purrr::imap( -->
<!--         \(r, idx) { -->
<!--           c( -->
<!--             rep(0, max(0, idx - 2)), # left pad with zeros -->
<!--             progression_rates[idx - 1] * r, -->
<!--             - progression_rates[idx] * r, -->
<!--             rep(0, K + L - idx) # right pad with zeros -->
<!--           ) -->
<!--         } -->
<!--       ) |> -->
<!--       purrr::reduce(`+`) -->
<!--   } -->

<!--   M[k, ] <- active_row -->
<!-- } -->

<!-- # Define the vector for the matrix multiplication -->
<!-- ss <- signal[2:(K + 1)]  -->
<!-- ss[is.na(ss)] <- 0 -->

<!-- checkmate::assert_number(nrow(M), lower = ncol(M) - 2, upper = ncol(M)) -->

<!-- # Add additional constraints -->
<!-- # I* = sum_l I_l -->
<!-- if (nrow(M) < ncol(M)) { -->
<!--   M <- rbind( -->
<!--     M,  -->
<!--     c(rep(0, K), w) -->
<!--   ) -->
<!--   ss <- c(ss, signal[1]) -->
<!-- } -->

<!-- # Add additional constraints -->
<!-- # I*(1/ri) = sum_l^(L-1) I_l + re/ri E_K -->
<!-- if (nrow(M) < ncol(M)) { -->
<!--   time_ratio <- re / (2 * ri) -->
<!--   k <- min(floor(time_ratio), K) -->
<!--   contribution <- c(rep(0, K - k), rep(1, k)) -->
<!--   contribution[max(K - k, 1)] <- contribution[max(K - k, 1)] + time_ratio - k -->

<!--   M <- rbind( -->
<!--     M,  -->
<!--     c(contribution * w[1], rep(0.5, L) * w + c(rep(0.5, L-1), 0) * w[2:L]) -->
<!--   ) -->
<!--   ss <- c(ss, predict(polyfit(-max(K, L) / ri * 0.5), data.frame(t = 0))) -->
<!-- } -->

<!-- tryCatch( -->
<!--   { -->
<!--     EI_states <-solve(M, ss) -->
<!--     EI_states <- EI_states / sum(EI_states) -->

<!--     stats::setNames( -->
<!--       EI_states, -->
<!--       c(paste0("E_", seq(K)), paste0("I_", seq(L))) -->
<!--     ) -->
<!--   }, -->
<!--   error = function(e) print(e$message) -->
<!-- ) -->
<!-- ``` -->

<!-- ## Implementation of true-infected signal with population constraint -->
<!-- ```{r} -->
<!-- K <- 2 # Number of E states -->
<!-- L <- 2 # Number of I states -->
<!-- ri <- rI * L -->
<!-- re <- rE * K -->


<!-- # Compute the derivatives of the signal ("signal" vector) -->
<!-- signal <- polyfit(0)$coefficients |> -->
<!--   (\(coefficients) coefficients* pmax(1, seq_along(coefficients) - 1))() -->
<!-- names(signal) <- c("I^*", "dI^*/dt", "d^2I^*/dt^2") -->

<!-- # Compute the matrix -->
<!-- M <- matrix(rep(0, (K + L) * K), ncol = K + L) -->
<!-- active_row <- c(rep(0, K - 1), re, rep(0, L - 1), -ri) -->
<!-- progression_rates <- c(rep(re, K), rep(ri, L)) -->

<!-- for (k in seq(K)) { -->
<!--   if (k > 1) { -->
<!--     stopifnot(active_row[[1]] == 0) # We cannot iterate too deeply -->

<!--     # Implement branching process which picks up the progression rate factors as it branches down. -->
<!--     active_row <- active_row |> -->
<!--       purrr::imap( -->
<!--         \(r, idx) { -->
<!--           c( -->
<!--             rep(0, max(0, idx - 2)), # left pad with zeros -->
<!--             progression_rates[idx - 1] * r, -->
<!--             - progression_rates[idx] * r, -->
<!--             rep(0, K + L - idx) # right pad with zeros -->
<!--           ) -->
<!--         } -->
<!--       ) |> -->
<!--       purrr::reduce(`+`) -->
<!--   } -->

<!--   M[k, ] <- active_row -->
<!-- } -->

<!-- # Define the vector for the matrix multiplication -->
<!-- ss <- signal[2:(K + 1)]  -->
<!-- ss[is.na(ss)] <- 0 -->

<!-- checkmate::assert_number(nrow(M), lower = ncol(M) - 2, upper = ncol(M)) -->

<!-- # Add additional constraints -->
<!-- # I* = sum_l I_l -->
<!-- if (nrow(M) < ncol(M)) { -->
<!--   M <- rbind( -->
<!--     M,  -->
<!--     c(rep(0, K), rep(1, L)) -->
<!--   ) -->
<!--   ss <- c(ss, signal[1]) -->
<!-- } -->

<!-- # Add additional constraints -->
<!-- # sum_k E_k + sum_l I_l = 1 - S - R -->
<!-- if (nrow(M) < ncol(M)) { -->
<!--   M <- rbind( -->
<!--     M,  -->
<!--     rep(1, K + L) -->
<!--   ) -->
<!--   ss <- c(ss, 1 - S[length(S)] - R[length(R)]) -->
<!-- } -->


<!-- EI_states <- solve(M, ss) -->
<!-- EI_states <- EI_states / sum(EI_states) -->

<!-- stats::setNames( -->
<!--   EI_states, -->
<!--   c(paste0("E_", seq(K)), paste0("I_", seq(L))) -->
<!-- ) -->
<!-- ``` -->



